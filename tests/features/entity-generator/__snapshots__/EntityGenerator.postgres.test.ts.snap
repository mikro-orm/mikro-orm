// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`EntityGenerator > enum with default value [postgres] > postgres-entity-dump-enum-default-value 1`] = `
[
  "import { type Opt, defineEntity, p } from '@mikro-orm/core';

export class Publisher2 {
  id!: number;
  test?: string = '123';
  type: TPublisher2Type & Opt = Publisher2Type.LOCAL;
  type2?: TPublisher2Type2 = Publisher2Type2.LOCAL;
}

export const Publisher2Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher2Type = (typeof Publisher2Type)[keyof typeof Publisher2Type];

export const Publisher2Type2 = {
  LOCAL: 'LOCAL',
  GLOBAL: 'GLOBAL',
} as const;

export type TPublisher2Type2 = (typeof Publisher2Type2)[keyof typeof Publisher2Type2];

export const Publisher2Schema = defineEntity({
  class: Publisher2,
  properties: {
    id: p.integer().primary(),
    test: p.string().length(-1).nullable(),
    type: p.enum(() => Publisher2Type),
    type2: p.enum(() => Publisher2Type2).nullable(),
  },
});
",
]
`;

exports[`EntityGenerator > generate entities from schema [postgres] > postgres-entity-dump 1`] = `
[
  "import { type Ref, defineEntity, p } from '@mikro-orm/core';
import { Label2 } from './Label2';
import { Test2 } from './Test2';

export class Label2Tests {
  id!: number;
  label2!: Ref<Label2>;
  test2!: Ref<Test2>;
}

export const Label2TestsSchema = defineEntity({
  class: Label2Tests,
  tableName: 'label2_tests',
  schema: 'label_schema',
  properties: {
    id: p.integer().primary(),
    label2: () => p.manyToOne(Label2).ref().updateRule('cascade').deleteRule('cascade'),
    test2: () => p.manyToOne(Test2).ref().updateRule('cascade').deleteRule('cascade'),
  },
});
",
  "import { PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Author2 } from './Author2';

export class Address2 {
  [PrimaryKeyProp]?: 'author';
  author!: Ref<Author2>;
  value!: string;
}

export const Address2Schema = defineEntity({
  class: Address2,
  comment: 'This is address table',
  properties: {
    author: () => p.oneToOne(Author2).primary().ref().updateRule('cascade').deleteRule('cascade'),
    value: p.string().comment('This is address property'),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Address2 } from './Address2';
import { Book2 } from './Book2';

export class Author2 {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string[];
  born?: string;
  bornTime?: string;
  favouriteBook?: Ref<Book2>;
  favouriteAuthor?: Ref<Author2>;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
  address2?: Ref<Address2>;
  author2Collection = new Collection<Author2>(this);
  authorToFriendInverse = new Collection<Author2>(this);
  followingInverse = new Collection<Author2>(this);
  book2Collection = new Collection<Book2>(this);
}

export const Author2Schema = defineEntity({
  class: Author2,
  indexes: [{ name: 'author2_name_age_index', properties: ['name', 'age'] }],
  uniques: [{ name: 'author2_name_email_unique', properties: ['name', 'email'] }],
  properties: {
    id: p.integer().primary(),
    createdAt: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
    updatedAt: p.datetime().columnType('timestamp(3)').defaultRaw(\`current_timestamp(3)\`),
    name: p.string().index('custom_idx_name_123'),
    email: p.string().index('custom_email_index_name').unique('custom_email_unique_name'),
    age: p.integer().nullable(),
    termsAccepted: p.boolean().index('author2_terms_accepted_index'),
    optional: p.boolean().nullable(),
    identities: p.type(string[]).nullable(),
    born: p.date().nullable().index('author2_born_index'),
    bornTime: p.time().length(0).nullable().index('born_time_idx'),
    favouriteBook: () => p.manyToOne(Book2).ref().deleteRule('cascade').nullable(),
    favouriteAuthor: () => p.manyToOne(Author2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    identity: p.json().nullable(),
    authorToFriend: () => p.manyToMany(Author2).pivotTable('author_to_friend').joinColumn('author2_1_id').inverseJoinColumn('author2_2_id'),
    following: () => p.manyToMany(Author2).joinColumn('author2_1_id').inverseJoinColumn('author2_2_id'),
    address2: () => p.oneToOne(Address2).ref().mappedBy('author'),
    author2Collection: () => p.oneToMany(Author2).mappedBy('favouriteAuthor'),
    authorToFriendInverse: () => p.manyToMany(Author2).mappedBy('authorToFriend'),
    followingInverse: () => p.manyToMany(Author2).mappedBy('following'),
    book2Collection: () => p.oneToMany(Book2).mappedBy('author'),
  },
});
",
  "import { Collection, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { Book2Tags } from './Book2Tags';

export class BookTag2 {
  id!: bigint;
  name!: string;
  bookToTagUnorderedInverse = new Collection<Book2>(this);
  book2TagsCollection = new Collection<Book2Tags>(this);
}

export const BookTag2Schema = defineEntity({
  class: BookTag2,
  properties: {
    id: p.bigint().primary(),
    name: p.string().length(50),
    bookToTagUnorderedInverse: () => p.manyToMany(Book2).mappedBy('bookToTagUnordered'),
    book2TagsCollection: () => p.oneToMany(Book2Tags).mappedBy('bookTag2'),
  },
});
",
  "import { Collection, type Opt, PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { Book2Tags } from './Book2Tags';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Book2 {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  isbn?: string;
  title?: string = '';
  perex?: string;
  price?: string;
  double?: string;
  meta?: any;
  author!: Ref<Author2>;
  publisher?: Ref<Publisher2>;
  foo?: string = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
  author2Collection = new Collection<Author2>(this);
  book2TagsCollection = new Collection<Book2Tags>(this);
  test2?: Ref<Test2>;
}

export const Book2Schema = defineEntity({
  class: Book2,
  properties: {
    uuidPk: p.uuid().primary(),
    createdAt: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
    isbn: p.character().length(13).nullable().unique('book_isbn_unique'),
    title: p.string().nullable(),
    perex: p.text().nullable(),
    price: p.decimal().precision(8).scale(2).nullable(),
    double: p.decimal().nullable(),
    meta: p.json().nullable(),
    author: () => p.manyToOne(Author2).ref(),
    publisher: () => p.manyToOne(Publisher2).ref().updateRule('cascade').deleteRule('cascade').nullable(),
    foo: p.string().nullable(),
    bookToTagUnordered: () => p.manyToMany(BookTag2).pivotTable('book_to_tag_unordered').joinColumn('book2_uuid_pk').inverseJoinColumn('book_tag2_id'),
    author2Collection: () => p.oneToMany(Author2).mappedBy('favouriteBook'),
    book2TagsCollection: () => p.oneToMany(Book2Tags).mappedBy('book2'),
    test2: () => p.oneToOne(Test2).ref().mappedBy('book'),
  },
});
",
  "import { PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Ref<Book2>;
  bookTag2!: Ref<BookTag2>;
}

export const Book2TagsSchema = defineEntity({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: p.integer().primary(),
    book2: () => p.manyToOne(Book2).ref().updateRule('cascade').deleteRule('cascade'),
    bookTag2: () => p.manyToOne(BookTag2).ref().updateRule('cascade').deleteRule('cascade'),
  },
});
",
  "import { PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Test2 } from './Test2';

export class Configuration2 {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Ref<Test2>;
  value!: string;
}

export const Configuration2Schema = defineEntity({
  class: Configuration2,
  properties: {
    property: p.string().primary(),
    test: () => p.manyToOne(Test2).primary().ref().updateRule('cascade'),
    value: p.string(),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { FooBaz2 } from './FooBaz2';
import { FooParam2 } from './FooParam2';
import { Test2 } from './Test2';

export class FooBar2 {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: Ref<FooBaz2>;
  fooBar?: Ref<FooBar2>;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string[];
  objectProperty?: any;
  fooBar2?: Ref<FooBar2>;
  fooParam2Collection = new Collection<FooParam2>(this);
  barsInverse = new Collection<Test2>(this);
}

export const FooBar2Schema = defineEntity({
  class: FooBar2,
  properties: {
    id: p.integer().primary(),
    name: p.string(),
    nameWithSpace: p.string().name('name with space').nullable(),
    baz: () => p.oneToOne(FooBaz2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    fooBar: () => p.oneToOne(FooBar2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    version: p.datetime().length(0).defaultRaw(\`current_timestamp(0)\`),
    blob: p.blob().nullable(),
    blob2: p.blob().nullable(),
    array: p.type(string[]).nullable(),
    objectProperty: p.json().nullable(),
    fooBar2: () => p.oneToOne(FooBar2).ref().mappedBy('fooBar'),
    fooParam2Collection: () => p.oneToMany(FooParam2).mappedBy('bar'),
    barsInverse: () => p.manyToMany(Test2).mappedBy('bars'),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooParam2 } from './FooParam2';

export class FooBaz2 {
  id!: number;
  name!: string;
  code!: string;
  version!: Date & Opt;
  fooBar2?: Ref<FooBar2>;
  fooParam2Collection = new Collection<FooParam2>(this);
}

export const FooBaz2Schema = defineEntity({
  class: FooBaz2,
  properties: {
    id: p.integer().primary(),
    name: p.string(),
    code: p.string(),
    version: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
    fooBar2: () => p.oneToOne(FooBar2).ref().mappedBy('baz'),
    fooParam2Collection: () => p.oneToMany(FooParam2).mappedBy('baz'),
  },
});
",
  "import { type Opt, PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: Ref<FooBar2>;
  baz!: Ref<FooBaz2>;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = defineEntity({
  class: FooParam2,
  properties: {
    bar: () => p.manyToOne(FooBar2).primary().ref().updateRule('cascade'),
    baz: () => p.manyToOne(FooBaz2).primary().ref().updateRule('cascade'),
    value: p.string(),
    version: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
  },
});
",
  "import { Collection, defineEntity, p } from '@mikro-orm/core';
import { Label2Tests } from './Label2Tests';

export class Label2 {
  uuid!: string;
  name!: string;
  label2TestsCollection = new Collection<Label2Tests>(this);
}

export const Label2Schema = defineEntity({
  class: Label2,
  properties: {
    uuid: p.uuid().primary(),
    name: p.string(),
    label2TestsCollection: () => p.oneToMany(Label2Tests).mappedBy('label2'),
  },
});
",
  "import { Collection, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { Publisher2Tests } from './Publisher2Tests';

export class Publisher2 {
  id!: number;
  name!: string;
  type!: TPublisher2Type;
  type2!: TPublisher2Type2;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: TPublisher2Enum4;
  enum5?: TPublisher2Enum5;
  book2Collection = new Collection<Book2>(this);
  publisher2TestsCollection = new Collection<Publisher2Tests>(this);
}

export const Publisher2Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher2Type = (typeof Publisher2Type)[keyof typeof Publisher2Type];

export const Publisher2Type2 = {
  LOCAL: 'LOCAL',
  GLOBAL: 'GLOBAL',
} as const;

export type TPublisher2Type2 = (typeof Publisher2Type2)[keyof typeof Publisher2Type2];

export const Publisher2Enum4 = {
  A: 'a',
  B: 'b',
  C: 'c',
} as const;

export type TPublisher2Enum4 = (typeof Publisher2Enum4)[keyof typeof Publisher2Enum4];

export const Publisher2Enum5 = {
  A: 'a',
} as const;

export type TPublisher2Enum5 = (typeof Publisher2Enum5)[keyof typeof Publisher2Enum5];

export const Publisher2Schema = defineEntity({
  class: Publisher2,
  properties: {
    id: p.integer().primary(),
    name: p.string(),
    type: p.enum(() => Publisher2Type),
    type2: p.enum(() => Publisher2Type2),
    enum1: p.smallint().nullable(),
    enum2: p.smallint().nullable(),
    enum3: p.smallint().nullable(),
    enum4: p.enum(() => Publisher2Enum4).nullable(),
    enum5: p.enum(() => Publisher2Enum5).nullable(),
    book2Collection: () => p.oneToMany(Book2).mappedBy('publisher'),
    publisher2TestsCollection: () => p.oneToMany(Publisher2Tests).mappedBy('publisher2'),
  },
});
",
  "import { type Ref, defineEntity, p } from '@mikro-orm/core';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests {
  id!: number;
  publisher2!: Ref<Publisher2>;
  test2!: Ref<Test2>;
}

export const Publisher2TestsSchema = defineEntity({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: p.integer().primary(),
    publisher2: () => p.manyToOne(Publisher2).ref().updateRule('cascade').deleteRule('cascade'),
    test2: () => p.manyToOne(Test2).ref().updateRule('cascade').deleteRule('cascade'),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { Configuration2 } from './Configuration2';
import { FooBar2 } from './FooBar2';
import { Label2Tests } from './Label2Tests';
import { Publisher2Tests } from './Publisher2Tests';

export class Test2 {
  id!: number;
  name?: string;
  book?: Ref<Book2>;
  parent?: Ref<Test2>;
  version: number & Opt = 1;
  path?: unknown;
  bars = new Collection<FooBar2>(this);
  label2TestsCollection = new Collection<Label2Tests>(this);
  configuration2Collection = new Collection<Configuration2>(this);
  publisher2TestsCollection = new Collection<Publisher2Tests>(this);
  test2Collection = new Collection<Test2>(this);
}

export const Test2Schema = defineEntity({
  class: Test2,
  properties: {
    id: p.integer().primary(),
    name: p.string().nullable(),
    book: () => p.oneToOne(Book2).ref().deleteRule('set null').nullable(),
    parent: () => p.manyToOne(Test2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    version: p.integer(),
    path: p.unknown().columnType('polygon').nullable(),
    bars: () => p.manyToMany(FooBar2).joinColumn('test2_id').inverseJoinColumn('foo_bar2_id'),
    label2TestsCollection: () => p.oneToMany(Label2Tests).mappedBy('test2'),
    configuration2Collection: () => p.oneToMany(Configuration2).mappedBy('test'),
    publisher2TestsCollection: () => p.oneToMany(Publisher2Tests).mappedBy('test2'),
    test2Collection: () => p.oneToMany(Test2).mappedBy('parent'),
  },
});
",
]
`;

exports[`EntityGenerator > generate entities from schema with forceUndefined = false [postgres] > postgres-entity-dump 1`] = `
[
  "import { type Ref, defineEntity, p } from '@mikro-orm/core';
import { Label2 } from './Label2';
import { Test2 } from './Test2';

export class Label2Tests {
  id!: number;
  label2!: Ref<Label2>;
  test2!: Ref<Test2>;
}

export const Label2TestsSchema = defineEntity({
  class: Label2Tests,
  tableName: 'label2_tests',
  schema: 'label_schema',
  properties: {
    id: p.integer().primary(),
    label2: () => p.manyToOne(Label2).ref().updateRule('cascade').deleteRule('cascade'),
    test2: () => p.manyToOne(Test2).ref().updateRule('cascade').deleteRule('cascade'),
  },
});
",
  "import { PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Author2 } from './Author2';

export class Address2 {
  [PrimaryKeyProp]?: 'author';
  author!: Ref<Author2>;
  value!: string;
}

export const Address2Schema = defineEntity({
  class: Address2,
  comment: 'This is address table',
  properties: {
    author: () => p.oneToOne(Author2).primary().ref().updateRule('cascade').deleteRule('cascade'),
    value: p.string().comment('This is address property'),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Address2 } from './Address2';
import { Book2 } from './Book2';

export class Author2 {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age: number | null = null;
  termsAccepted: boolean & Opt = false;
  optional: boolean | null = null;
  identities: string[] | null = null;
  born: string | null = null;
  bornTime: string | null = null;
  favouriteBook: Ref<Book2> | null = null;
  favouriteAuthor: Ref<Author2> | null = null;
  identity: any | null = null;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
  address2: Ref<Address2> | null = null;
  author2Collection = new Collection<Author2>(this);
  authorToFriendInverse = new Collection<Author2>(this);
  followingInverse = new Collection<Author2>(this);
  book2Collection = new Collection<Book2>(this);
}

export const Author2Schema = defineEntity({
  class: Author2,
  indexes: [{ name: 'author2_name_age_index', properties: ['name', 'age'] }],
  uniques: [{ name: 'author2_name_email_unique', properties: ['name', 'email'] }],
  properties: {
    id: p.integer().primary(),
    createdAt: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
    updatedAt: p.datetime().columnType('timestamp(3)').defaultRaw(\`current_timestamp(3)\`),
    name: p.string().index('custom_idx_name_123'),
    email: p.string().index('custom_email_index_name').unique('custom_email_unique_name'),
    age: p.integer().nullable(),
    termsAccepted: p.boolean().index('author2_terms_accepted_index'),
    optional: p.boolean().nullable(),
    identities: p.type(string[]).nullable(),
    born: p.date().nullable().index('author2_born_index'),
    bornTime: p.time().length(0).nullable().index('born_time_idx'),
    favouriteBook: () => p.manyToOne(Book2).ref().deleteRule('cascade').nullable(),
    favouriteAuthor: () => p.manyToOne(Author2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    identity: p.json().nullable(),
    authorToFriend: () => p.manyToMany(Author2).pivotTable('author_to_friend').joinColumn('author2_1_id').inverseJoinColumn('author2_2_id'),
    following: () => p.manyToMany(Author2).joinColumn('author2_1_id').inverseJoinColumn('author2_2_id'),
    address2: () => p.oneToOne(Address2).ref().mappedBy('author'),
    author2Collection: () => p.oneToMany(Author2).mappedBy('favouriteAuthor'),
    authorToFriendInverse: () => p.manyToMany(Author2).mappedBy('authorToFriend'),
    followingInverse: () => p.manyToMany(Author2).mappedBy('following'),
    book2Collection: () => p.oneToMany(Book2).mappedBy('author'),
  },
});
",
  "import { Collection, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { Book2Tags } from './Book2Tags';

export class BookTag2 {
  id!: bigint;
  name!: string;
  bookToTagUnorderedInverse = new Collection<Book2>(this);
  book2TagsCollection = new Collection<Book2Tags>(this);
}

export const BookTag2Schema = defineEntity({
  class: BookTag2,
  properties: {
    id: p.bigint().primary(),
    name: p.string().length(50),
    bookToTagUnorderedInverse: () => p.manyToMany(Book2).mappedBy('bookToTagUnordered'),
    book2TagsCollection: () => p.oneToMany(Book2Tags).mappedBy('bookTag2'),
  },
});
",
  "import { Collection, type Opt, PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { Book2Tags } from './Book2Tags';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Book2 {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  isbn: string | null = null;
  title?: string | null = '';
  perex: string | null = null;
  price: string | null = null;
  double: string | null = null;
  meta: any | null = null;
  author!: Ref<Author2>;
  publisher: Ref<Publisher2> | null = null;
  foo?: string | null = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
  author2Collection = new Collection<Author2>(this);
  book2TagsCollection = new Collection<Book2Tags>(this);
  test2: Ref<Test2> | null = null;
}

export const Book2Schema = defineEntity({
  class: Book2,
  properties: {
    uuidPk: p.uuid().primary(),
    createdAt: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
    isbn: p.character().length(13).nullable().unique('book_isbn_unique'),
    title: p.string().nullable(),
    perex: p.text().nullable(),
    price: p.decimal().precision(8).scale(2).nullable(),
    double: p.decimal().nullable(),
    meta: p.json().nullable(),
    author: () => p.manyToOne(Author2).ref(),
    publisher: () => p.manyToOne(Publisher2).ref().updateRule('cascade').deleteRule('cascade').nullable(),
    foo: p.string().nullable(),
    bookToTagUnordered: () => p.manyToMany(BookTag2).pivotTable('book_to_tag_unordered').joinColumn('book2_uuid_pk').inverseJoinColumn('book_tag2_id'),
    author2Collection: () => p.oneToMany(Author2).mappedBy('favouriteBook'),
    book2TagsCollection: () => p.oneToMany(Book2Tags).mappedBy('book2'),
    test2: () => p.oneToOne(Test2).ref().mappedBy('book'),
  },
});
",
  "import { PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Ref<Book2>;
  bookTag2!: Ref<BookTag2>;
}

export const Book2TagsSchema = defineEntity({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: p.integer().primary(),
    book2: () => p.manyToOne(Book2).ref().updateRule('cascade').deleteRule('cascade'),
    bookTag2: () => p.manyToOne(BookTag2).ref().updateRule('cascade').deleteRule('cascade'),
  },
});
",
  "import { PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Test2 } from './Test2';

export class Configuration2 {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Ref<Test2>;
  value!: string;
}

export const Configuration2Schema = defineEntity({
  class: Configuration2,
  properties: {
    property: p.string().primary(),
    test: () => p.manyToOne(Test2).primary().ref().updateRule('cascade'),
    value: p.string(),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { FooBaz2 } from './FooBaz2';
import { FooParam2 } from './FooParam2';
import { Test2 } from './Test2';

export class FooBar2 {
  id!: number;
  name!: string;
  nameWithSpace: string | null = null;
  baz: Ref<FooBaz2> | null = null;
  fooBar: Ref<FooBar2> | null = null;
  version!: Date & Opt;
  blob: Buffer | null = null;
  blob2: Buffer | null = null;
  array: string[] | null = null;
  objectProperty: any | null = null;
  fooBar2: Ref<FooBar2> | null = null;
  fooParam2Collection = new Collection<FooParam2>(this);
  barsInverse = new Collection<Test2>(this);
}

export const FooBar2Schema = defineEntity({
  class: FooBar2,
  properties: {
    id: p.integer().primary(),
    name: p.string(),
    nameWithSpace: p.string().name('name with space').nullable(),
    baz: () => p.oneToOne(FooBaz2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    fooBar: () => p.oneToOne(FooBar2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    version: p.datetime().length(0).defaultRaw(\`current_timestamp(0)\`),
    blob: p.blob().nullable(),
    blob2: p.blob().nullable(),
    array: p.type(string[]).nullable(),
    objectProperty: p.json().nullable(),
    fooBar2: () => p.oneToOne(FooBar2).ref().mappedBy('fooBar'),
    fooParam2Collection: () => p.oneToMany(FooParam2).mappedBy('bar'),
    barsInverse: () => p.manyToMany(Test2).mappedBy('bars'),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooParam2 } from './FooParam2';

export class FooBaz2 {
  id!: number;
  name!: string;
  code!: string;
  version!: Date & Opt;
  fooBar2: Ref<FooBar2> | null = null;
  fooParam2Collection = new Collection<FooParam2>(this);
}

export const FooBaz2Schema = defineEntity({
  class: FooBaz2,
  properties: {
    id: p.integer().primary(),
    name: p.string(),
    code: p.string(),
    version: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
    fooBar2: () => p.oneToOne(FooBar2).ref().mappedBy('baz'),
    fooParam2Collection: () => p.oneToMany(FooParam2).mappedBy('baz'),
  },
});
",
  "import { type Opt, PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: Ref<FooBar2>;
  baz!: Ref<FooBaz2>;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = defineEntity({
  class: FooParam2,
  properties: {
    bar: () => p.manyToOne(FooBar2).primary().ref().updateRule('cascade'),
    baz: () => p.manyToOne(FooBaz2).primary().ref().updateRule('cascade'),
    value: p.string(),
    version: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
  },
});
",
  "import { Collection, defineEntity, p } from '@mikro-orm/core';
import { Label2Tests } from './Label2Tests';

export class Label2 {
  uuid!: string;
  name!: string;
  label2TestsCollection = new Collection<Label2Tests>(this);
}

export const Label2Schema = defineEntity({
  class: Label2,
  properties: {
    uuid: p.uuid().primary(),
    name: p.string(),
    label2TestsCollection: () => p.oneToMany(Label2Tests).mappedBy('label2'),
  },
});
",
  "import { Collection, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { Publisher2Tests } from './Publisher2Tests';

export class Publisher2 {
  id!: number;
  name!: string;
  type!: TPublisher2Type;
  type2!: TPublisher2Type2;
  enum1: number | null = null;
  enum2: number | null = null;
  enum3: number | null = null;
  enum4: TPublisher2Enum4 | null = null;
  enum5: TPublisher2Enum5 | null = null;
  book2Collection = new Collection<Book2>(this);
  publisher2TestsCollection = new Collection<Publisher2Tests>(this);
}

export const Publisher2Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher2Type = (typeof Publisher2Type)[keyof typeof Publisher2Type];

export const Publisher2Type2 = {
  LOCAL: 'LOCAL',
  GLOBAL: 'GLOBAL',
} as const;

export type TPublisher2Type2 = (typeof Publisher2Type2)[keyof typeof Publisher2Type2];

export const Publisher2Enum4 = {
  A: 'a',
  B: 'b',
  C: 'c',
} as const;

export type TPublisher2Enum4 = (typeof Publisher2Enum4)[keyof typeof Publisher2Enum4];

export const Publisher2Enum5 = {
  A: 'a',
} as const;

export type TPublisher2Enum5 = (typeof Publisher2Enum5)[keyof typeof Publisher2Enum5];

export const Publisher2Schema = defineEntity({
  class: Publisher2,
  properties: {
    id: p.integer().primary(),
    name: p.string(),
    type: p.enum(() => Publisher2Type),
    type2: p.enum(() => Publisher2Type2),
    enum1: p.smallint().nullable(),
    enum2: p.smallint().nullable(),
    enum3: p.smallint().nullable(),
    enum4: p.enum(() => Publisher2Enum4).nullable(),
    enum5: p.enum(() => Publisher2Enum5).nullable(),
    book2Collection: () => p.oneToMany(Book2).mappedBy('publisher'),
    publisher2TestsCollection: () => p.oneToMany(Publisher2Tests).mappedBy('publisher2'),
  },
});
",
  "import { type Ref, defineEntity, p } from '@mikro-orm/core';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests {
  id!: number;
  publisher2!: Ref<Publisher2>;
  test2!: Ref<Test2>;
}

export const Publisher2TestsSchema = defineEntity({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: p.integer().primary(),
    publisher2: () => p.manyToOne(Publisher2).ref().updateRule('cascade').deleteRule('cascade'),
    test2: () => p.manyToOne(Test2).ref().updateRule('cascade').deleteRule('cascade'),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { Configuration2 } from './Configuration2';
import { FooBar2 } from './FooBar2';
import { Label2Tests } from './Label2Tests';
import { Publisher2Tests } from './Publisher2Tests';

export class Test2 {
  id!: number;
  name: string | null = null;
  book: Ref<Book2> | null = null;
  parent: Ref<Test2> | null = null;
  version: number & Opt = 1;
  path: unknown | null = null;
  bars = new Collection<FooBar2>(this);
  label2TestsCollection = new Collection<Label2Tests>(this);
  configuration2Collection = new Collection<Configuration2>(this);
  publisher2TestsCollection = new Collection<Publisher2Tests>(this);
  test2Collection = new Collection<Test2>(this);
}

export const Test2Schema = defineEntity({
  class: Test2,
  properties: {
    id: p.integer().primary(),
    name: p.string().nullable(),
    book: () => p.oneToOne(Book2).ref().deleteRule('set null').nullable(),
    parent: () => p.manyToOne(Test2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    version: p.integer(),
    path: p.unknown().columnType('polygon').nullable(),
    bars: () => p.manyToMany(FooBar2).joinColumn('test2_id').inverseJoinColumn('foo_bar2_id'),
    label2TestsCollection: () => p.oneToMany(Label2Tests).mappedBy('test2'),
    configuration2Collection: () => p.oneToMany(Configuration2).mappedBy('test'),
    publisher2TestsCollection: () => p.oneToMany(Publisher2Tests).mappedBy('test2'),
    test2Collection: () => p.oneToMany(Test2).mappedBy('parent'),
  },
});
",
]
`;

exports[`EntityGenerator > generate entities from schema with forceUndefined = false and undefinedDefaults = true [postgres] > postgres-entity-dump 1`] = `
[
  "import { type Ref, defineEntity, p } from '@mikro-orm/core';
import { Label2 } from './Label2';
import { Test2 } from './Test2';

export class Label2Tests {
  id!: number;
  label2!: Ref<Label2>;
  test2!: Ref<Test2>;
}

export const Label2TestsSchema = defineEntity({
  class: Label2Tests,
  tableName: 'label2_tests',
  schema: 'label_schema',
  properties: {
    id: p.integer().primary(),
    label2: () => p.manyToOne(Label2).ref().updateRule('cascade').deleteRule('cascade'),
    test2: () => p.manyToOne(Test2).ref().updateRule('cascade').deleteRule('cascade'),
  },
});
",
  "import { PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Author2 } from './Author2';

export class Address2 {
  [PrimaryKeyProp]?: 'author';
  author!: Ref<Author2>;
  value!: string;
}

export const Address2Schema = defineEntity({
  class: Address2,
  comment: 'This is address table',
  properties: {
    author: () => p.oneToOne(Author2).primary().ref().updateRule('cascade').deleteRule('cascade'),
    value: p.string().comment('This is address property'),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Address2 } from './Address2';
import { Book2 } from './Book2';

export class Author2 {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number | null;
  termsAccepted: boolean & Opt = false;
  optional?: boolean | null;
  identities?: string[] | null;
  born?: string | null;
  bornTime?: string | null;
  favouriteBook?: Ref<Book2> | null;
  favouriteAuthor?: Ref<Author2> | null;
  identity?: any | null;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
  address2: Ref<Address2> | null = null;
  author2Collection = new Collection<Author2>(this);
  authorToFriendInverse = new Collection<Author2>(this);
  followingInverse = new Collection<Author2>(this);
  book2Collection = new Collection<Book2>(this);
}

export const Author2Schema = defineEntity({
  class: Author2,
  indexes: [{ name: 'author2_name_age_index', properties: ['name', 'age'] }],
  uniques: [{ name: 'author2_name_email_unique', properties: ['name', 'email'] }],
  properties: {
    id: p.integer().primary(),
    createdAt: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
    updatedAt: p.datetime().columnType('timestamp(3)').defaultRaw(\`current_timestamp(3)\`),
    name: p.string().index('custom_idx_name_123'),
    email: p.string().index('custom_email_index_name').unique('custom_email_unique_name'),
    age: p.integer().nullable(),
    termsAccepted: p.boolean().index('author2_terms_accepted_index'),
    optional: p.boolean().nullable(),
    identities: p.type(string[]).nullable(),
    born: p.date().nullable().index('author2_born_index'),
    bornTime: p.time().length(0).nullable().index('born_time_idx'),
    favouriteBook: () => p.manyToOne(Book2).ref().deleteRule('cascade').nullable(),
    favouriteAuthor: () => p.manyToOne(Author2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    identity: p.json().nullable(),
    authorToFriend: () => p.manyToMany(Author2).pivotTable('author_to_friend').joinColumn('author2_1_id').inverseJoinColumn('author2_2_id'),
    following: () => p.manyToMany(Author2).joinColumn('author2_1_id').inverseJoinColumn('author2_2_id'),
    address2: () => p.oneToOne(Address2).ref().mappedBy('author'),
    author2Collection: () => p.oneToMany(Author2).mappedBy('favouriteAuthor'),
    authorToFriendInverse: () => p.manyToMany(Author2).mappedBy('authorToFriend'),
    followingInverse: () => p.manyToMany(Author2).mappedBy('following'),
    book2Collection: () => p.oneToMany(Book2).mappedBy('author'),
  },
});
",
  "import { Collection, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { Book2Tags } from './Book2Tags';

export class BookTag2 {
  id!: bigint;
  name!: string;
  bookToTagUnorderedInverse = new Collection<Book2>(this);
  book2TagsCollection = new Collection<Book2Tags>(this);
}

export const BookTag2Schema = defineEntity({
  class: BookTag2,
  properties: {
    id: p.bigint().primary(),
    name: p.string().length(50),
    bookToTagUnorderedInverse: () => p.manyToMany(Book2).mappedBy('bookToTagUnordered'),
    book2TagsCollection: () => p.oneToMany(Book2Tags).mappedBy('bookTag2'),
  },
});
",
  "import { Collection, type Opt, PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { Book2Tags } from './Book2Tags';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Book2 {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  isbn?: string | null;
  title?: string | null = '';
  perex?: string | null;
  price?: string | null;
  double?: string | null;
  meta?: any | null;
  author!: Ref<Author2>;
  publisher?: Ref<Publisher2> | null;
  foo?: string | null = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
  author2Collection = new Collection<Author2>(this);
  book2TagsCollection = new Collection<Book2Tags>(this);
  test2: Ref<Test2> | null = null;
}

export const Book2Schema = defineEntity({
  class: Book2,
  properties: {
    uuidPk: p.uuid().primary(),
    createdAt: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
    isbn: p.character().length(13).nullable().unique('book_isbn_unique'),
    title: p.string().nullable(),
    perex: p.text().nullable(),
    price: p.decimal().precision(8).scale(2).nullable(),
    double: p.decimal().nullable(),
    meta: p.json().nullable(),
    author: () => p.manyToOne(Author2).ref(),
    publisher: () => p.manyToOne(Publisher2).ref().updateRule('cascade').deleteRule('cascade').nullable(),
    foo: p.string().nullable(),
    bookToTagUnordered: () => p.manyToMany(BookTag2).pivotTable('book_to_tag_unordered').joinColumn('book2_uuid_pk').inverseJoinColumn('book_tag2_id'),
    author2Collection: () => p.oneToMany(Author2).mappedBy('favouriteBook'),
    book2TagsCollection: () => p.oneToMany(Book2Tags).mappedBy('book2'),
    test2: () => p.oneToOne(Test2).ref().mappedBy('book'),
  },
});
",
  "import { PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Ref<Book2>;
  bookTag2!: Ref<BookTag2>;
}

export const Book2TagsSchema = defineEntity({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: p.integer().primary(),
    book2: () => p.manyToOne(Book2).ref().updateRule('cascade').deleteRule('cascade'),
    bookTag2: () => p.manyToOne(BookTag2).ref().updateRule('cascade').deleteRule('cascade'),
  },
});
",
  "import { PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Test2 } from './Test2';

export class Configuration2 {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Ref<Test2>;
  value!: string;
}

export const Configuration2Schema = defineEntity({
  class: Configuration2,
  properties: {
    property: p.string().primary(),
    test: () => p.manyToOne(Test2).primary().ref().updateRule('cascade'),
    value: p.string(),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { FooBaz2 } from './FooBaz2';
import { FooParam2 } from './FooParam2';
import { Test2 } from './Test2';

export class FooBar2 {
  id!: number;
  name!: string;
  nameWithSpace?: string | null;
  baz?: Ref<FooBaz2> | null;
  fooBar?: Ref<FooBar2> | null;
  version!: Date & Opt;
  blob?: Buffer | null;
  blob2?: Buffer | null;
  array?: string[] | null;
  objectProperty?: any | null;
  fooBar2: Ref<FooBar2> | null = null;
  fooParam2Collection = new Collection<FooParam2>(this);
  barsInverse = new Collection<Test2>(this);
}

export const FooBar2Schema = defineEntity({
  class: FooBar2,
  properties: {
    id: p.integer().primary(),
    name: p.string(),
    nameWithSpace: p.string().name('name with space').nullable(),
    baz: () => p.oneToOne(FooBaz2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    fooBar: () => p.oneToOne(FooBar2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    version: p.datetime().length(0).defaultRaw(\`current_timestamp(0)\`),
    blob: p.blob().nullable(),
    blob2: p.blob().nullable(),
    array: p.type(string[]).nullable(),
    objectProperty: p.json().nullable(),
    fooBar2: () => p.oneToOne(FooBar2).ref().mappedBy('fooBar'),
    fooParam2Collection: () => p.oneToMany(FooParam2).mappedBy('bar'),
    barsInverse: () => p.manyToMany(Test2).mappedBy('bars'),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooParam2 } from './FooParam2';

export class FooBaz2 {
  id!: number;
  name!: string;
  code!: string;
  version!: Date & Opt;
  fooBar2: Ref<FooBar2> | null = null;
  fooParam2Collection = new Collection<FooParam2>(this);
}

export const FooBaz2Schema = defineEntity({
  class: FooBaz2,
  properties: {
    id: p.integer().primary(),
    name: p.string(),
    code: p.string(),
    version: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
    fooBar2: () => p.oneToOne(FooBar2).ref().mappedBy('baz'),
    fooParam2Collection: () => p.oneToMany(FooParam2).mappedBy('baz'),
  },
});
",
  "import { type Opt, PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: Ref<FooBar2>;
  baz!: Ref<FooBaz2>;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = defineEntity({
  class: FooParam2,
  properties: {
    bar: () => p.manyToOne(FooBar2).primary().ref().updateRule('cascade'),
    baz: () => p.manyToOne(FooBaz2).primary().ref().updateRule('cascade'),
    value: p.string(),
    version: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
  },
});
",
  "import { Collection, defineEntity, p } from '@mikro-orm/core';
import { Label2Tests } from './Label2Tests';

export class Label2 {
  uuid!: string;
  name!: string;
  label2TestsCollection = new Collection<Label2Tests>(this);
}

export const Label2Schema = defineEntity({
  class: Label2,
  properties: {
    uuid: p.uuid().primary(),
    name: p.string(),
    label2TestsCollection: () => p.oneToMany(Label2Tests).mappedBy('label2'),
  },
});
",
  "import { Collection, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { Publisher2Tests } from './Publisher2Tests';

export class Publisher2 {
  id!: number;
  name!: string;
  type!: TPublisher2Type;
  type2!: TPublisher2Type2;
  enum1?: number | null;
  enum2?: number | null;
  enum3?: number | null;
  enum4?: TPublisher2Enum4 | null;
  enum5?: TPublisher2Enum5 | null;
  book2Collection = new Collection<Book2>(this);
  publisher2TestsCollection = new Collection<Publisher2Tests>(this);
}

export const Publisher2Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher2Type = (typeof Publisher2Type)[keyof typeof Publisher2Type];

export const Publisher2Type2 = {
  LOCAL: 'LOCAL',
  GLOBAL: 'GLOBAL',
} as const;

export type TPublisher2Type2 = (typeof Publisher2Type2)[keyof typeof Publisher2Type2];

export const Publisher2Enum4 = {
  A: 'a',
  B: 'b',
  C: 'c',
} as const;

export type TPublisher2Enum4 = (typeof Publisher2Enum4)[keyof typeof Publisher2Enum4];

export const Publisher2Enum5 = {
  A: 'a',
} as const;

export type TPublisher2Enum5 = (typeof Publisher2Enum5)[keyof typeof Publisher2Enum5];

export const Publisher2Schema = defineEntity({
  class: Publisher2,
  properties: {
    id: p.integer().primary(),
    name: p.string(),
    type: p.enum(() => Publisher2Type),
    type2: p.enum(() => Publisher2Type2),
    enum1: p.smallint().nullable(),
    enum2: p.smallint().nullable(),
    enum3: p.smallint().nullable(),
    enum4: p.enum(() => Publisher2Enum4).nullable(),
    enum5: p.enum(() => Publisher2Enum5).nullable(),
    book2Collection: () => p.oneToMany(Book2).mappedBy('publisher'),
    publisher2TestsCollection: () => p.oneToMany(Publisher2Tests).mappedBy('publisher2'),
  },
});
",
  "import { type Ref, defineEntity, p } from '@mikro-orm/core';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests {
  id!: number;
  publisher2!: Ref<Publisher2>;
  test2!: Ref<Test2>;
}

export const Publisher2TestsSchema = defineEntity({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: p.integer().primary(),
    publisher2: () => p.manyToOne(Publisher2).ref().updateRule('cascade').deleteRule('cascade'),
    test2: () => p.manyToOne(Test2).ref().updateRule('cascade').deleteRule('cascade'),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { Configuration2 } from './Configuration2';
import { FooBar2 } from './FooBar2';
import { Label2Tests } from './Label2Tests';
import { Publisher2Tests } from './Publisher2Tests';

export class Test2 {
  id!: number;
  name?: string | null;
  book?: Ref<Book2> | null;
  parent?: Ref<Test2> | null;
  version: number & Opt = 1;
  path?: unknown | null;
  bars = new Collection<FooBar2>(this);
  label2TestsCollection = new Collection<Label2Tests>(this);
  configuration2Collection = new Collection<Configuration2>(this);
  publisher2TestsCollection = new Collection<Publisher2Tests>(this);
  test2Collection = new Collection<Test2>(this);
}

export const Test2Schema = defineEntity({
  class: Test2,
  properties: {
    id: p.integer().primary(),
    name: p.string().nullable(),
    book: () => p.oneToOne(Book2).ref().deleteRule('set null').nullable(),
    parent: () => p.manyToOne(Test2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    version: p.integer(),
    path: p.unknown().columnType('polygon').nullable(),
    bars: () => p.manyToMany(FooBar2).joinColumn('test2_id').inverseJoinColumn('foo_bar2_id'),
    label2TestsCollection: () => p.oneToMany(Label2Tests).mappedBy('test2'),
    configuration2Collection: () => p.oneToMany(Configuration2).mappedBy('test'),
    publisher2TestsCollection: () => p.oneToMany(Publisher2Tests).mappedBy('test2'),
    test2Collection: () => p.oneToMany(Test2).mappedBy('parent'),
  },
});
",
]
`;

exports[`EntityGenerator > skipTables [postgres] > postgres-entity-dump-skipTables 1`] = `
[
  "import { type Ref, defineEntity, p } from '@mikro-orm/core';
import { Label2 } from './Label2';

export class Label2Tests {
  id!: number;
  label2!: Ref<Label2>;
  test2!: number;
}

export const Label2TestsSchema = defineEntity({
  class: Label2Tests,
  tableName: 'label2_tests',
  schema: 'label_schema',
  properties: {
    id: p.integer().primary(),
    label2: () => p.manyToOne(Label2).ref().updateRule('cascade').deleteRule('cascade'),
    test2: p.integer().name('test2_id'),
  },
});
",
  "import { PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Author2 } from './Author2';

export class Address2 {
  [PrimaryKeyProp]?: 'author';
  author!: Ref<Author2>;
  value!: string;
}

export const Address2Schema = defineEntity({
  class: Address2,
  comment: 'This is address table',
  properties: {
    author: () => p.oneToOne(Author2).primary().ref().updateRule('cascade').deleteRule('cascade'),
    value: p.string().comment('This is address property'),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Address2 } from './Address2';
import { Book2 } from './Book2';

export class Author2 {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string[];
  born?: string;
  bornTime?: string;
  favouriteBook?: Ref<Book2>;
  favouriteAuthor?: Ref<Author2>;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
  address2?: Ref<Address2>;
  author2Collection = new Collection<Author2>(this);
  authorToFriendInverse = new Collection<Author2>(this);
  followingInverse = new Collection<Author2>(this);
  book2Collection = new Collection<Book2>(this);
}

export const Author2Schema = defineEntity({
  class: Author2,
  indexes: [{ name: 'author2_name_age_index', properties: ['name', 'age'] }],
  uniques: [{ name: 'author2_name_email_unique', properties: ['name', 'email'] }],
  properties: {
    id: p.integer().primary(),
    createdAt: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
    updatedAt: p.datetime().columnType('timestamp(3)').defaultRaw(\`current_timestamp(3)\`),
    name: p.string().index('custom_idx_name_123'),
    email: p.string().index('custom_email_index_name').unique('custom_email_unique_name'),
    age: p.integer().nullable(),
    termsAccepted: p.boolean().index('author2_terms_accepted_index'),
    optional: p.boolean().nullable(),
    identities: p.type(string[]).nullable(),
    born: p.date().nullable().index('author2_born_index'),
    bornTime: p.time().length(0).nullable().index('born_time_idx'),
    favouriteBook: () => p.manyToOne(Book2).ref().deleteRule('cascade').nullable(),
    favouriteAuthor: () => p.manyToOne(Author2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    identity: p.json().nullable(),
    authorToFriend: () => p.manyToMany(Author2).pivotTable('author_to_friend').joinColumn('author2_1_id').inverseJoinColumn('author2_2_id'),
    following: () => p.manyToMany(Author2).joinColumn('author2_1_id').inverseJoinColumn('author2_2_id'),
    address2: () => p.oneToOne(Address2).ref().mappedBy('author'),
    author2Collection: () => p.oneToMany(Author2).mappedBy('favouriteAuthor'),
    authorToFriendInverse: () => p.manyToMany(Author2).mappedBy('authorToFriend'),
    followingInverse: () => p.manyToMany(Author2).mappedBy('following'),
    book2Collection: () => p.oneToMany(Book2).mappedBy('author'),
  },
});
",
  "import { Collection, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { Book2Tags } from './Book2Tags';

export class BookTag2 {
  id!: bigint;
  name!: string;
  bookToTagUnorderedInverse = new Collection<Book2>(this);
  book2TagsCollection = new Collection<Book2Tags>(this);
}

export const BookTag2Schema = defineEntity({
  class: BookTag2,
  properties: {
    id: p.bigint().primary(),
    name: p.string().length(50),
    bookToTagUnorderedInverse: () => p.manyToMany(Book2).mappedBy('bookToTagUnordered'),
    book2TagsCollection: () => p.oneToMany(Book2Tags).mappedBy('bookTag2'),
  },
});
",
  "import { Collection, type Opt, PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { Book2Tags } from './Book2Tags';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

export class Book2 {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  isbn?: string;
  title?: string = '';
  perex?: string;
  double?: string;
  meta?: any;
  author!: Ref<Author2>;
  publisher?: Ref<Publisher2>;
  foo?: string = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
  author2Collection = new Collection<Author2>(this);
  book2TagsCollection = new Collection<Book2Tags>(this);
}

export const Book2Schema = defineEntity({
  class: Book2,
  properties: {
    uuidPk: p.uuid().primary(),
    createdAt: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
    isbn: p.character().length(13).nullable().unique('book_isbn_unique'),
    title: p.string().nullable(),
    perex: p.text().nullable(),
    double: p.decimal().nullable(),
    meta: p.json().nullable(),
    author: () => p.manyToOne(Author2).ref(),
    publisher: () => p.manyToOne(Publisher2).ref().updateRule('cascade').deleteRule('cascade').nullable(),
    foo: p.string().nullable(),
    bookToTagUnordered: () => p.manyToMany(BookTag2).pivotTable('book_to_tag_unordered').joinColumn('book2_uuid_pk').inverseJoinColumn('book_tag2_id'),
    author2Collection: () => p.oneToMany(Author2).mappedBy('favouriteBook'),
    book2TagsCollection: () => p.oneToMany(Book2Tags).mappedBy('book2'),
  },
});
",
  "import { PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Ref<Book2>;
  bookTag2!: Ref<BookTag2>;
}

export const Book2TagsSchema = defineEntity({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: p.integer().primary(),
    book2: () => p.manyToOne(Book2).ref().updateRule('cascade').deleteRule('cascade'),
    bookTag2: () => p.manyToOne(BookTag2).ref().updateRule('cascade').deleteRule('cascade'),
  },
});
",
  "import { PrimaryKeyProp, defineEntity, p } from '@mikro-orm/core';

export class Configuration2 {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: number;
  value!: string;
}

export const Configuration2Schema = defineEntity({
  class: Configuration2,
  properties: {
    property: p.string().primary(),
    test: p.integer().primary().name('test_id'),
    value: p.string(),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { FooBaz2 } from './FooBaz2';
import { FooParam2 } from './FooParam2';

export class FooBar2 {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: Ref<FooBaz2>;
  fooBar?: Ref<FooBar2>;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string[];
  objectProperty?: any;
  fooBar2?: Ref<FooBar2>;
  fooParam2Collection = new Collection<FooParam2>(this);
}

export const FooBar2Schema = defineEntity({
  class: FooBar2,
  properties: {
    id: p.integer().primary(),
    name: p.string(),
    nameWithSpace: p.string().name('name with space').nullable(),
    baz: () => p.oneToOne(FooBaz2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    fooBar: () => p.oneToOne(FooBar2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    version: p.datetime().length(0).defaultRaw(\`current_timestamp(0)\`),
    blob: p.blob().nullable(),
    blob2: p.blob().nullable(),
    array: p.type(string[]).nullable(),
    objectProperty: p.json().nullable(),
    fooBar2: () => p.oneToOne(FooBar2).ref().mappedBy('fooBar'),
    fooParam2Collection: () => p.oneToMany(FooParam2).mappedBy('bar'),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooParam2 } from './FooParam2';

export class FooBaz2 {
  id!: number;
  code!: string;
  version!: Date & Opt;
  fooBar2?: Ref<FooBar2>;
  fooParam2Collection = new Collection<FooParam2>(this);
}

export const FooBaz2Schema = defineEntity({
  class: FooBaz2,
  properties: {
    id: p.integer().primary(),
    code: p.string(),
    version: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
    fooBar2: () => p.oneToOne(FooBar2).ref().mappedBy('baz'),
    fooParam2Collection: () => p.oneToMany(FooParam2).mappedBy('baz'),
  },
});
",
  "import { type Opt, PrimaryKeyProp, type Ref, defineEntity, p } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: Ref<FooBar2>;
  baz!: Ref<FooBaz2>;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = defineEntity({
  class: FooParam2,
  properties: {
    bar: () => p.manyToOne(FooBar2).primary().ref().updateRule('cascade'),
    baz: () => p.manyToOne(FooBaz2).primary().ref().updateRule('cascade'),
    value: p.string(),
    version: p.datetime().length(3).defaultRaw(\`current_timestamp(3)\`),
  },
});
",
  "import { Collection, defineEntity, p } from '@mikro-orm/core';
import { Label2Tests } from './Label2Tests';

export class Label2 {
  uuid!: string;
  name!: string;
  label2TestsCollection = new Collection<Label2Tests>(this);
}

export const Label2Schema = defineEntity({
  class: Label2,
  properties: {
    uuid: p.uuid().primary(),
    name: p.string(),
    label2TestsCollection: () => p.oneToMany(Label2Tests).mappedBy('label2'),
  },
});
",
  "import { Collection, defineEntity, p } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { Publisher2Tests } from './Publisher2Tests';

export class Publisher2 {
  id!: number;
  name!: string;
  type!: TPublisher2Type;
  type2!: TPublisher2Type2;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: TPublisher2Enum4;
  enum5?: TPublisher2Enum5;
  book2Collection = new Collection<Book2>(this);
  publisher2TestsCollection = new Collection<Publisher2Tests>(this);
}

export const Publisher2Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher2Type = (typeof Publisher2Type)[keyof typeof Publisher2Type];

export const Publisher2Type2 = {
  LOCAL: 'LOCAL',
  GLOBAL: 'GLOBAL',
} as const;

export type TPublisher2Type2 = (typeof Publisher2Type2)[keyof typeof Publisher2Type2];

export const Publisher2Enum4 = {
  A: 'a',
  B: 'b',
  C: 'c',
} as const;

export type TPublisher2Enum4 = (typeof Publisher2Enum4)[keyof typeof Publisher2Enum4];

export const Publisher2Enum5 = {
  A: 'a',
} as const;

export type TPublisher2Enum5 = (typeof Publisher2Enum5)[keyof typeof Publisher2Enum5];

export const Publisher2Schema = defineEntity({
  class: Publisher2,
  properties: {
    id: p.integer().primary(),
    name: p.string(),
    type: p.enum(() => Publisher2Type),
    type2: p.enum(() => Publisher2Type2),
    enum1: p.smallint().nullable(),
    enum2: p.smallint().nullable(),
    enum3: p.smallint().nullable(),
    enum4: p.enum(() => Publisher2Enum4).nullable(),
    enum5: p.enum(() => Publisher2Enum5).nullable(),
    book2Collection: () => p.oneToMany(Book2).mappedBy('publisher'),
    publisher2TestsCollection: () => p.oneToMany(Publisher2Tests).mappedBy('publisher2'),
  },
});
",
  "import { type Ref, defineEntity, p } from '@mikro-orm/core';
import { Publisher2 } from './Publisher2';

export class Publisher2Tests {
  id!: number;
  publisher2!: Ref<Publisher2>;
  test2!: number;
}

export const Publisher2TestsSchema = defineEntity({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: p.integer().primary(),
    publisher2: () => p.manyToOne(Publisher2).ref().updateRule('cascade').deleteRule('cascade'),
    test2: p.integer().name('test2_id'),
  },
});
",
]
`;

exports[`EntityGenerator > takeTables [postgres] > postgres-entity-dump-takeTables 1`] = `
[
  "import { type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';

export class FooBar2 {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: number;
  fooBar?: Ref<FooBar2>;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string[];
  objectProperty?: any;
  fooBar2?: Ref<FooBar2>;
}

export const FooBar2Schema = defineEntity({
  class: FooBar2,
  properties: {
    id: p.integer().primary(),
    name: p.string(),
    nameWithSpace: p.string().name('name with space').nullable(),
    baz: p.integer().name('baz_id').nullable().unique('foo_bar2_baz_id_unique'),
    fooBar: () => p.oneToOne(FooBar2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    version: p.datetime().length(0).defaultRaw(\`current_timestamp(0)\`),
    blob: p.blob().nullable(),
    blob2: p.blob().nullable(),
    array: p.type(string[]).nullable(),
    objectProperty: p.json().nullable(),
    fooBar2: () => p.oneToOne(FooBar2).ref().mappedBy('fooBar'),
  },
});
",
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';

export class Test2 {
  id!: number;
  name?: string;
  book?: string;
  parent?: Ref<Test2>;
  version: number & Opt = 1;
  path?: unknown;
  test2Collection = new Collection<Test2>(this);
}

export const Test2Schema = defineEntity({
  class: Test2,
  properties: {
    id: p.integer().primary(),
    name: p.string().nullable(),
    book: p.uuid().name('book_uuid_pk').nullable().unique('test2_book_uuid_pk_unique'),
    parent: () => p.manyToOne(Test2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    version: p.integer(),
    path: p.unknown().columnType('polygon').nullable(),
    test2Collection: () => p.oneToMany(Test2).mappedBy('parent'),
  },
});
",
]
`;

exports[`EntityGenerator > takeTables and skipTables [postgres] > postgres-entity-dump-takeTables-skipTables 1`] = `
[
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';

export class Test2 {
  id!: number;
  name?: string;
  book?: string;
  parent?: Ref<Test2>;
  version: number & Opt = 1;
  path?: unknown;
  test2Collection = new Collection<Test2>(this);
}

export const Test2Schema = defineEntity({
  class: Test2,
  properties: {
    id: p.integer().primary(),
    name: p.string().nullable(),
    book: p.uuid().name('book_uuid_pk').nullable().unique('test2_book_uuid_pk_unique'),
    parent: () => p.manyToOne(Test2).ref().updateRule('cascade').deleteRule('set null').nullable(),
    version: p.integer(),
    path: p.unknown().columnType('polygon').nullable(),
    test2Collection: () => p.oneToMany(Test2).mappedBy('parent'),
  },
});
",
]
`;
