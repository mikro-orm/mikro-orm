// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`overlap_fk_example > scalarPropertiesForRelations=always > bidirectionalRelations=false > identifiedReferences=false > entitySchema=false > dump 1`] = `
[
  "import { Entity, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';

@Entity()
export class Countries {

  [PrimaryKeyProp]?: 'code';

  @PrimaryKey({ type: 'character', length: 2 })
  code!: string;

}
",
  "import { Entity, Index, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';

@Entity()
@Index({ name: 'full_idx', properties: ['countries', 'productId', 'isCurrentlyAllowed'] })
@Index({ name: 'primary_reindex_idx', properties: ['countries', 'productId'] })
export class ProductCountryMap {

  [PrimaryKeyProp]?: ['product', 'countries'];

  @Property({ type: 'character', length: 2, persist: false })
  country!: string;

  @ManyToOne({ entity: () => Products, fieldName: 'product_id', primary: true, index: 'fk_product_country_map_products1' })
  product!: Products;

  @Property({ unsigned: true, persist: false, index: 'fk_product_country_map_products1' })
  productId!: number;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

  @ManyToOne({ entity: () => Countries, fieldName: 'country', primary: true })
  countries!: Countries;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Products } from './Products';
import { Sellers } from './Sellers';

@Entity()
export class ProductSellers {

  [PrimaryKeyProp]?: ['seller', 'product'];

  @ManyToOne({ entity: () => Sellers, fieldName: 'seller_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  seller!: Sellers;

  @Property({ unsigned: true, persist: false })
  sellerId!: number;

  @ManyToOne({ entity: () => Products, fieldName: 'product_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true, index: 'fk_product_sellers_products1' })
  product!: Products;

  @Property({ unsigned: true, persist: false, index: 'fk_product_sellers_products1' })
  productId!: number;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

}
",
  "import { Collection, Entity, ManyToMany, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';

@Entity()
export class Products {

  [PrimaryKeyProp]?: 'productId';

  @PrimaryKey()
  productId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  currentPrice!: string;

  @Property({ type: 'integer' })
  currentQuantity: number & Opt = 0;

  @ManyToMany({ entity: () => Countries, pivotTable: 'product_country_map', pivotEntity: () => ProductCountryMap, joinColumn: 'product_id', inverseJoinColumn: 'country' })
  productCountryMap = new Collection<Countries>(this);

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

@Entity()
export class Sales {

  [PrimaryKeyProp]?: 'saleId';

  @PrimaryKey()
  saleId!: number;

  @Property({ type: 'character', length: 2, persist: false })
  country!: string;

  @ManyToOne({ entity: () => ProductSellers, fieldNames: ['seller_id', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_sellers1_idx' })
  seller!: ProductSellers;

  @Property({ unsigned: true, persist: false })
  sellerId!: number;

  @Property({ unsigned: true, persist: false, index: 'product_id_idx' })
  productId!: number;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  singularPrice!: string;

  @Property({ type: 'integer', unsigned: true })
  quantitySold: number & Opt = 1;

  @ManyToOne({ entity: () => ProductCountryMap, fieldNames: ['country', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_country_map1_idx' })
  productCountryMap!: ProductCountryMap;

}
",
  "import { Collection, Entity, ManyToMany, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

@Entity()
export class Sellers {

  [PrimaryKeyProp]?: 'sellerId';

  @PrimaryKey()
  sellerId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_sellers', pivotEntity: () => ProductSellers, joinColumn: 'seller_id', inverseJoinColumn: 'product_id' })
  productSellers = new Collection<Products>(this);

}
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=always > bidirectionalRelations=false > identifiedReferences=false > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';

export class Countries {
  [PrimaryKeyProp]?: 'code';
  code!: string;
}

export const CountriesSchema = new EntitySchema({
  class: Countries,
  properties: {
    code: { primary: true, type: 'character', length: 2 },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';

export class ProductCountryMap {
  [PrimaryKeyProp]?: ['product', 'countries'];
  country!: string;
  product!: Products;
  productId!: number;
  isCurrentlyAllowed: boolean & Opt = false;
  countries!: Countries;
}

export const ProductCountryMapSchema = new EntitySchema({
  class: ProductCountryMap,
  indexes: [
    {
      name: 'full_idx',
      properties: ['countries', 'productId', 'isCurrentlyAllowed'],
    },
    { name: 'primary_reindex_idx', properties: ['countries', 'productId'] },
  ],
  properties: {
    country: { type: 'character', length: 2, persist: false },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      fieldName: 'product_id',
      index: 'fk_product_country_map_products1',
    },
    productId: {
      type: 'integer',
      unsigned: true,
      persist: false,
      index: 'fk_product_country_map_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
    countries: {
      primary: true,
      kind: 'm:1',
      entity: () => Countries,
      fieldName: 'country',
    },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Products } from './Products';
import { Sellers } from './Sellers';

export class ProductSellers {
  [PrimaryKeyProp]?: ['seller', 'product'];
  seller!: Sellers;
  sellerId!: number;
  product!: Products;
  productId!: number;
  isCurrentlyAllowed: boolean & Opt = false;
}

export const ProductSellersSchema = new EntitySchema({
  class: ProductSellers,
  properties: {
    seller: {
      primary: true,
      kind: 'm:1',
      entity: () => Sellers,
      fieldName: 'seller_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    sellerId: { type: 'integer', unsigned: true, persist: false },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      fieldName: 'product_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
      index: 'fk_product_sellers_products1',
    },
    productId: {
      type: 'integer',
      unsigned: true,
      persist: false,
      index: 'fk_product_sellers_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';

export class Products {
  [PrimaryKeyProp]?: 'productId';
  productId!: number;
  name!: string;
  currentPrice!: string;
  currentQuantity: number & Opt = 0;
  productCountryMap = new Collection<Countries>(this);
}

export const ProductsSchema = new EntitySchema({
  class: Products,
  properties: {
    productId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    currentPrice: { type: 'decimal', precision: 10, scale: 2 },
    currentQuantity: { type: 'integer' },
    productCountryMap: {
      kind: 'm:n',
      entity: () => Countries,
      pivotTable: 'product_country_map',
      pivotEntity: () => ProductCountryMap,
      joinColumn: 'product_id',
      inverseJoinColumn: 'country',
    },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

export class Sales {
  [PrimaryKeyProp]?: 'saleId';
  saleId!: number;
  country!: string;
  seller!: ProductSellers;
  sellerId!: number;
  productId!: number;
  singularPrice!: string;
  quantitySold: number & Opt = 1;
  productCountryMap!: ProductCountryMap;
}

export const SalesSchema = new EntitySchema({
  class: Sales,
  properties: {
    saleId: { primary: true, type: 'integer' },
    country: { type: 'character', length: 2, persist: false },
    seller: {
      kind: 'm:1',
      entity: () => ProductSellers,
      fieldNames: ['seller_id', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_sellers1_idx',
    },
    sellerId: { type: 'integer', unsigned: true, persist: false },
    productId: {
      type: 'integer',
      unsigned: true,
      persist: false,
      index: 'product_id_idx',
    },
    singularPrice: { type: 'decimal', precision: 10, scale: 2 },
    quantitySold: { type: 'integer', unsigned: true },
    productCountryMap: {
      kind: 'm:1',
      entity: () => ProductCountryMap,
      fieldNames: ['country', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_country_map1_idx',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

export class Sellers {
  [PrimaryKeyProp]?: 'sellerId';
  sellerId!: number;
  name!: string;
  productSellers = new Collection<Products>(this);
}

export const SellersSchema = new EntitySchema({
  class: Sellers,
  properties: {
    sellerId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    productSellers: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_sellers',
      pivotEntity: () => ProductSellers,
      joinColumn: 'seller_id',
      inverseJoinColumn: 'product_id',
    },
  },
});
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=always > bidirectionalRelations=false > identifiedReferences=true > entitySchema=false > dump 1`] = `
[
  "import { Entity, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';

@Entity()
export class Countries {

  [PrimaryKeyProp]?: 'code';

  @PrimaryKey({ type: 'character', length: 2 })
  code!: string;

}
",
  "import { Entity, Index, ManyToOne, type Opt, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';

@Entity()
@Index({ name: 'full_idx', properties: ['countries', 'productId', 'isCurrentlyAllowed'] })
@Index({ name: 'primary_reindex_idx', properties: ['countries', 'productId'] })
export class ProductCountryMap {

  [PrimaryKeyProp]?: ['product', 'countries'];

  @Property({ type: 'character', length: 2, persist: false })
  country!: string;

  @ManyToOne({ entity: () => Products, ref: true, fieldName: 'product_id', primary: true, index: 'fk_product_country_map_products1' })
  product!: Ref<Products>;

  @Property({ unsigned: true, persist: false, index: 'fk_product_country_map_products1' })
  productId!: number;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

  @ManyToOne({ entity: () => Countries, ref: true, fieldName: 'country', primary: true })
  countries!: Ref<Countries>;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { Products } from './Products';
import { Sellers } from './Sellers';

@Entity()
export class ProductSellers {

  [PrimaryKeyProp]?: ['seller', 'product'];

  @ManyToOne({ entity: () => Sellers, ref: true, fieldName: 'seller_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  seller!: Ref<Sellers>;

  @Property({ unsigned: true, persist: false })
  sellerId!: number;

  @ManyToOne({ entity: () => Products, ref: true, fieldName: 'product_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true, index: 'fk_product_sellers_products1' })
  product!: Ref<Products>;

  @Property({ unsigned: true, persist: false, index: 'fk_product_sellers_products1' })
  productId!: number;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

}
",
  "import { Collection, Entity, ManyToMany, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';

@Entity()
export class Products {

  [PrimaryKeyProp]?: 'productId';

  @PrimaryKey()
  productId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  currentPrice!: string;

  @Property({ type: 'integer' })
  currentQuantity: number & Opt = 0;

  @ManyToMany({ entity: () => Countries, pivotTable: 'product_country_map', pivotEntity: () => ProductCountryMap, joinColumn: 'product_id', inverseJoinColumn: 'country' })
  productCountryMap = new Collection<Countries>(this);

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

@Entity()
export class Sales {

  [PrimaryKeyProp]?: 'saleId';

  @PrimaryKey()
  saleId!: number;

  @Property({ type: 'character', length: 2, persist: false })
  country!: string;

  @ManyToOne({ entity: () => ProductSellers, ref: true, fieldNames: ['seller_id', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_sellers1_idx' })
  seller!: Ref<ProductSellers>;

  @Property({ unsigned: true, persist: false })
  sellerId!: number;

  @Property({ unsigned: true, persist: false, index: 'product_id_idx' })
  productId!: number;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  singularPrice!: string;

  @Property({ type: 'integer', unsigned: true })
  quantitySold: number & Opt = 1;

  @ManyToOne({ entity: () => ProductCountryMap, ref: true, fieldNames: ['country', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_country_map1_idx' })
  productCountryMap!: Ref<ProductCountryMap>;

}
",
  "import { Collection, Entity, ManyToMany, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

@Entity()
export class Sellers {

  [PrimaryKeyProp]?: 'sellerId';

  @PrimaryKey()
  sellerId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_sellers', pivotEntity: () => ProductSellers, joinColumn: 'seller_id', inverseJoinColumn: 'product_id' })
  productSellers = new Collection<Products>(this);

}
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=always > bidirectionalRelations=false > identifiedReferences=true > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';

export class Countries {
  [PrimaryKeyProp]?: 'code';
  code!: string;
}

export const CountriesSchema = new EntitySchema({
  class: Countries,
  properties: {
    code: { primary: true, type: 'character', length: 2 },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';

export class ProductCountryMap {
  [PrimaryKeyProp]?: ['product', 'countries'];
  country!: string;
  product!: Ref<Products>;
  productId!: number;
  isCurrentlyAllowed: boolean & Opt = false;
  countries!: Ref<Countries>;
}

export const ProductCountryMapSchema = new EntitySchema({
  class: ProductCountryMap,
  indexes: [
    {
      name: 'full_idx',
      properties: ['countries', 'productId', 'isCurrentlyAllowed'],
    },
    { name: 'primary_reindex_idx', properties: ['countries', 'productId'] },
  ],
  properties: {
    country: { type: 'character', length: 2, persist: false },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      ref: true,
      fieldName: 'product_id',
      index: 'fk_product_country_map_products1',
    },
    productId: {
      type: 'integer',
      unsigned: true,
      persist: false,
      index: 'fk_product_country_map_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
    countries: {
      primary: true,
      kind: 'm:1',
      entity: () => Countries,
      ref: true,
      fieldName: 'country',
    },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { Products } from './Products';
import { Sellers } from './Sellers';

export class ProductSellers {
  [PrimaryKeyProp]?: ['seller', 'product'];
  seller!: Ref<Sellers>;
  sellerId!: number;
  product!: Ref<Products>;
  productId!: number;
  isCurrentlyAllowed: boolean & Opt = false;
}

export const ProductSellersSchema = new EntitySchema({
  class: ProductSellers,
  properties: {
    seller: {
      primary: true,
      kind: 'm:1',
      entity: () => Sellers,
      ref: true,
      fieldName: 'seller_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    sellerId: { type: 'integer', unsigned: true, persist: false },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      ref: true,
      fieldName: 'product_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
      index: 'fk_product_sellers_products1',
    },
    productId: {
      type: 'integer',
      unsigned: true,
      persist: false,
      index: 'fk_product_sellers_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';

export class Products {
  [PrimaryKeyProp]?: 'productId';
  productId!: number;
  name!: string;
  currentPrice!: string;
  currentQuantity: number & Opt = 0;
  productCountryMap = new Collection<Countries>(this);
}

export const ProductsSchema = new EntitySchema({
  class: Products,
  properties: {
    productId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    currentPrice: { type: 'decimal', precision: 10, scale: 2 },
    currentQuantity: { type: 'integer' },
    productCountryMap: {
      kind: 'm:n',
      entity: () => Countries,
      pivotTable: 'product_country_map',
      pivotEntity: () => ProductCountryMap,
      joinColumn: 'product_id',
      inverseJoinColumn: 'country',
    },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

export class Sales {
  [PrimaryKeyProp]?: 'saleId';
  saleId!: number;
  country!: string;
  seller!: Ref<ProductSellers>;
  sellerId!: number;
  productId!: number;
  singularPrice!: string;
  quantitySold: number & Opt = 1;
  productCountryMap!: Ref<ProductCountryMap>;
}

export const SalesSchema = new EntitySchema({
  class: Sales,
  properties: {
    saleId: { primary: true, type: 'integer' },
    country: { type: 'character', length: 2, persist: false },
    seller: {
      kind: 'm:1',
      entity: () => ProductSellers,
      ref: true,
      fieldNames: ['seller_id', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_sellers1_idx',
    },
    sellerId: { type: 'integer', unsigned: true, persist: false },
    productId: {
      type: 'integer',
      unsigned: true,
      persist: false,
      index: 'product_id_idx',
    },
    singularPrice: { type: 'decimal', precision: 10, scale: 2 },
    quantitySold: { type: 'integer', unsigned: true },
    productCountryMap: {
      kind: 'm:1',
      entity: () => ProductCountryMap,
      ref: true,
      fieldNames: ['country', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_country_map1_idx',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

export class Sellers {
  [PrimaryKeyProp]?: 'sellerId';
  sellerId!: number;
  name!: string;
  productSellers = new Collection<Products>(this);
}

export const SellersSchema = new EntitySchema({
  class: Sellers,
  properties: {
    sellerId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    productSellers: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_sellers',
      pivotEntity: () => ProductSellers,
      joinColumn: 'seller_id',
      inverseJoinColumn: 'product_id',
    },
  },
});
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=always > bidirectionalRelations=true > identifiedReferences=false > entitySchema=false > dump 1`] = `
[
  "import { Collection, Entity, ManyToMany, OneToMany, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

@Entity()
export class Countries {

  [PrimaryKeyProp]?: 'code';

  @PrimaryKey({ type: 'character', length: 2 })
  code!: string;

  @OneToMany({ entity: () => ProductCountryMap, mappedBy: 'countries' })
  productCountryMapCollection = new Collection<ProductCountryMap>(this);

  @ManyToMany({ entity: () => Products, mappedBy: 'productCountryMap' })
  productCountryMapInverse = new Collection<Products>(this);

}
",
  "import { Collection, Entity, Index, ManyToOne, OneToMany, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';
import { Sales } from './Sales';

@Entity()
@Index({ name: 'full_idx', properties: ['countries', 'productId', 'isCurrentlyAllowed'] })
@Index({ name: 'primary_reindex_idx', properties: ['countries', 'productId'] })
export class ProductCountryMap {

  [PrimaryKeyProp]?: ['product', 'countries'];

  @Property({ type: 'character', length: 2, persist: false })
  country!: string;

  @ManyToOne({ entity: () => Products, fieldName: 'product_id', primary: true, index: 'fk_product_country_map_products1' })
  product!: Products;

  @Property({ unsigned: true, persist: false, index: 'fk_product_country_map_products1' })
  productId!: number;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

  @ManyToOne({ entity: () => Countries, fieldName: 'country', primary: true })
  countries!: Countries;

  @OneToMany({ entity: () => Sales, mappedBy: 'productCountryMap' })
  salesCollection = new Collection<Sales>(this);

}
",
  "import { Collection, Entity, ManyToOne, OneToMany, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Products } from './Products';
import { Sales } from './Sales';
import { Sellers } from './Sellers';

@Entity()
export class ProductSellers {

  [PrimaryKeyProp]?: ['seller', 'product'];

  @ManyToOne({ entity: () => Sellers, fieldName: 'seller_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  seller!: Sellers;

  @Property({ unsigned: true, persist: false })
  sellerId!: number;

  @ManyToOne({ entity: () => Products, fieldName: 'product_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true, index: 'fk_product_sellers_products1' })
  product!: Products;

  @Property({ unsigned: true, persist: false, index: 'fk_product_sellers_products1' })
  productId!: number;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

  @OneToMany({ entity: () => Sales, mappedBy: 'seller' })
  salesCollection = new Collection<Sales>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToMany, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';
import { Sellers } from './Sellers';

@Entity()
export class Products {

  [PrimaryKeyProp]?: 'productId';

  @PrimaryKey()
  productId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  currentPrice!: string;

  @Property({ type: 'integer' })
  currentQuantity: number & Opt = 0;

  @ManyToMany({ entity: () => Countries, pivotTable: 'product_country_map', pivotEntity: () => ProductCountryMap, joinColumn: 'product_id', inverseJoinColumn: 'country' })
  productCountryMap = new Collection<Countries>(this);

  @OneToMany({ entity: () => ProductCountryMap, mappedBy: 'product' })
  productCountryMapCollection = new Collection<ProductCountryMap>(this);

  @OneToMany({ entity: () => ProductSellers, mappedBy: 'product' })
  productSellersCollection = new Collection<ProductSellers>(this);

  @ManyToMany({ entity: () => Sellers, mappedBy: 'productSellers' })
  productSellersInverse = new Collection<Sellers>(this);

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

@Entity()
export class Sales {

  [PrimaryKeyProp]?: 'saleId';

  @PrimaryKey()
  saleId!: number;

  @Property({ type: 'character', length: 2, persist: false })
  country!: string;

  @ManyToOne({ entity: () => ProductSellers, fieldNames: ['seller_id', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_sellers1_idx' })
  seller!: ProductSellers;

  @Property({ unsigned: true, persist: false })
  sellerId!: number;

  @Property({ unsigned: true, persist: false, index: 'product_id_idx' })
  productId!: number;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  singularPrice!: string;

  @Property({ type: 'integer', unsigned: true })
  quantitySold: number & Opt = 1;

  @ManyToOne({ entity: () => ProductCountryMap, fieldNames: ['country', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_country_map1_idx' })
  productCountryMap!: ProductCountryMap;

}
",
  "import { Collection, Entity, ManyToMany, OneToMany, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

@Entity()
export class Sellers {

  [PrimaryKeyProp]?: 'sellerId';

  @PrimaryKey()
  sellerId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_sellers', pivotEntity: () => ProductSellers, joinColumn: 'seller_id', inverseJoinColumn: 'product_id' })
  productSellers = new Collection<Products>(this);

  @OneToMany({ entity: () => ProductSellers, mappedBy: 'seller' })
  productSellersCollection = new Collection<ProductSellers>(this);

}
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=always > bidirectionalRelations=true > identifiedReferences=false > entitySchema=true > dump 1`] = `
[
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

export class Countries {
  [PrimaryKeyProp]?: 'code';
  code!: string;
  productCountryMapCollection = new Collection<ProductCountryMap>(this);
  productCountryMapInverse = new Collection<Products>(this);
}

export const CountriesSchema = new EntitySchema({
  class: Countries,
  properties: {
    code: { primary: true, type: 'character', length: 2 },
    productCountryMapCollection: {
      kind: '1:m',
      entity: () => ProductCountryMap,
      mappedBy: 'countries',
    },
    productCountryMapInverse: {
      kind: 'm:n',
      entity: () => Products,
      mappedBy: 'productCountryMap',
    },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';
import { Sales } from './Sales';

export class ProductCountryMap {
  [PrimaryKeyProp]?: ['product', 'countries'];
  country!: string;
  product!: Products;
  productId!: number;
  isCurrentlyAllowed: boolean & Opt = false;
  countries!: Countries;
  salesCollection = new Collection<Sales>(this);
}

export const ProductCountryMapSchema = new EntitySchema({
  class: ProductCountryMap,
  indexes: [
    {
      name: 'full_idx',
      properties: ['countries', 'productId', 'isCurrentlyAllowed'],
    },
    { name: 'primary_reindex_idx', properties: ['countries', 'productId'] },
  ],
  properties: {
    country: { type: 'character', length: 2, persist: false },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      fieldName: 'product_id',
      index: 'fk_product_country_map_products1',
    },
    productId: {
      type: 'integer',
      unsigned: true,
      persist: false,
      index: 'fk_product_country_map_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
    countries: {
      primary: true,
      kind: 'm:1',
      entity: () => Countries,
      fieldName: 'country',
    },
    salesCollection: {
      kind: '1:m',
      entity: () => Sales,
      mappedBy: 'productCountryMap',
    },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Products } from './Products';
import { Sales } from './Sales';
import { Sellers } from './Sellers';

export class ProductSellers {
  [PrimaryKeyProp]?: ['seller', 'product'];
  seller!: Sellers;
  sellerId!: number;
  product!: Products;
  productId!: number;
  isCurrentlyAllowed: boolean & Opt = false;
  salesCollection = new Collection<Sales>(this);
}

export const ProductSellersSchema = new EntitySchema({
  class: ProductSellers,
  properties: {
    seller: {
      primary: true,
      kind: 'm:1',
      entity: () => Sellers,
      fieldName: 'seller_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    sellerId: { type: 'integer', unsigned: true, persist: false },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      fieldName: 'product_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
      index: 'fk_product_sellers_products1',
    },
    productId: {
      type: 'integer',
      unsigned: true,
      persist: false,
      index: 'fk_product_sellers_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
    salesCollection: { kind: '1:m', entity: () => Sales, mappedBy: 'seller' },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';
import { Sellers } from './Sellers';

export class Products {
  [PrimaryKeyProp]?: 'productId';
  productId!: number;
  name!: string;
  currentPrice!: string;
  currentQuantity: number & Opt = 0;
  productCountryMap = new Collection<Countries>(this);
  productCountryMapCollection = new Collection<ProductCountryMap>(this);
  productSellersCollection = new Collection<ProductSellers>(this);
  productSellersInverse = new Collection<Sellers>(this);
}

export const ProductsSchema = new EntitySchema({
  class: Products,
  properties: {
    productId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    currentPrice: { type: 'decimal', precision: 10, scale: 2 },
    currentQuantity: { type: 'integer' },
    productCountryMap: {
      kind: 'm:n',
      entity: () => Countries,
      pivotTable: 'product_country_map',
      pivotEntity: () => ProductCountryMap,
      joinColumn: 'product_id',
      inverseJoinColumn: 'country',
    },
    productCountryMapCollection: {
      kind: '1:m',
      entity: () => ProductCountryMap,
      mappedBy: 'product',
    },
    productSellersCollection: {
      kind: '1:m',
      entity: () => ProductSellers,
      mappedBy: 'product',
    },
    productSellersInverse: {
      kind: 'm:n',
      entity: () => Sellers,
      mappedBy: 'productSellers',
    },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

export class Sales {
  [PrimaryKeyProp]?: 'saleId';
  saleId!: number;
  country!: string;
  seller!: ProductSellers;
  sellerId!: number;
  productId!: number;
  singularPrice!: string;
  quantitySold: number & Opt = 1;
  productCountryMap!: ProductCountryMap;
}

export const SalesSchema = new EntitySchema({
  class: Sales,
  properties: {
    saleId: { primary: true, type: 'integer' },
    country: { type: 'character', length: 2, persist: false },
    seller: {
      kind: 'm:1',
      entity: () => ProductSellers,
      fieldNames: ['seller_id', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_sellers1_idx',
    },
    sellerId: { type: 'integer', unsigned: true, persist: false },
    productId: {
      type: 'integer',
      unsigned: true,
      persist: false,
      index: 'product_id_idx',
    },
    singularPrice: { type: 'decimal', precision: 10, scale: 2 },
    quantitySold: { type: 'integer', unsigned: true },
    productCountryMap: {
      kind: 'm:1',
      entity: () => ProductCountryMap,
      fieldNames: ['country', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_country_map1_idx',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

export class Sellers {
  [PrimaryKeyProp]?: 'sellerId';
  sellerId!: number;
  name!: string;
  productSellers = new Collection<Products>(this);
  productSellersCollection = new Collection<ProductSellers>(this);
}

export const SellersSchema = new EntitySchema({
  class: Sellers,
  properties: {
    sellerId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    productSellers: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_sellers',
      pivotEntity: () => ProductSellers,
      joinColumn: 'seller_id',
      inverseJoinColumn: 'product_id',
    },
    productSellersCollection: {
      kind: '1:m',
      entity: () => ProductSellers,
      mappedBy: 'seller',
    },
  },
});
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=always > bidirectionalRelations=true > identifiedReferences=true > entitySchema=false > dump 1`] = `
[
  "import { Collection, Entity, ManyToMany, OneToMany, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

@Entity()
export class Countries {

  [PrimaryKeyProp]?: 'code';

  @PrimaryKey({ type: 'character', length: 2 })
  code!: string;

  @OneToMany({ entity: () => ProductCountryMap, mappedBy: 'countries' })
  productCountryMapCollection = new Collection<ProductCountryMap>(this);

  @ManyToMany({ entity: () => Products, mappedBy: 'productCountryMap' })
  productCountryMapInverse = new Collection<Products>(this);

}
",
  "import { Collection, Entity, Index, ManyToOne, OneToMany, type Opt, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';
import { Sales } from './Sales';

@Entity()
@Index({ name: 'full_idx', properties: ['countries', 'productId', 'isCurrentlyAllowed'] })
@Index({ name: 'primary_reindex_idx', properties: ['countries', 'productId'] })
export class ProductCountryMap {

  [PrimaryKeyProp]?: ['product', 'countries'];

  @Property({ type: 'character', length: 2, persist: false })
  country!: string;

  @ManyToOne({ entity: () => Products, ref: true, fieldName: 'product_id', primary: true, index: 'fk_product_country_map_products1' })
  product!: Ref<Products>;

  @Property({ unsigned: true, persist: false, index: 'fk_product_country_map_products1' })
  productId!: number;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

  @ManyToOne({ entity: () => Countries, ref: true, fieldName: 'country', primary: true })
  countries!: Ref<Countries>;

  @OneToMany({ entity: () => Sales, mappedBy: 'productCountryMap' })
  salesCollection = new Collection<Sales>(this);

}
",
  "import { Collection, Entity, ManyToOne, OneToMany, type Opt, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { Products } from './Products';
import { Sales } from './Sales';
import { Sellers } from './Sellers';

@Entity()
export class ProductSellers {

  [PrimaryKeyProp]?: ['seller', 'product'];

  @ManyToOne({ entity: () => Sellers, ref: true, fieldName: 'seller_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  seller!: Ref<Sellers>;

  @Property({ unsigned: true, persist: false })
  sellerId!: number;

  @ManyToOne({ entity: () => Products, ref: true, fieldName: 'product_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true, index: 'fk_product_sellers_products1' })
  product!: Ref<Products>;

  @Property({ unsigned: true, persist: false, index: 'fk_product_sellers_products1' })
  productId!: number;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

  @OneToMany({ entity: () => Sales, mappedBy: 'seller' })
  salesCollection = new Collection<Sales>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToMany, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';
import { Sellers } from './Sellers';

@Entity()
export class Products {

  [PrimaryKeyProp]?: 'productId';

  @PrimaryKey()
  productId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  currentPrice!: string;

  @Property({ type: 'integer' })
  currentQuantity: number & Opt = 0;

  @ManyToMany({ entity: () => Countries, pivotTable: 'product_country_map', pivotEntity: () => ProductCountryMap, joinColumn: 'product_id', inverseJoinColumn: 'country' })
  productCountryMap = new Collection<Countries>(this);

  @OneToMany({ entity: () => ProductCountryMap, mappedBy: 'product' })
  productCountryMapCollection = new Collection<ProductCountryMap>(this);

  @OneToMany({ entity: () => ProductSellers, mappedBy: 'product' })
  productSellersCollection = new Collection<ProductSellers>(this);

  @ManyToMany({ entity: () => Sellers, mappedBy: 'productSellers' })
  productSellersInverse = new Collection<Sellers>(this);

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

@Entity()
export class Sales {

  [PrimaryKeyProp]?: 'saleId';

  @PrimaryKey()
  saleId!: number;

  @Property({ type: 'character', length: 2, persist: false })
  country!: string;

  @ManyToOne({ entity: () => ProductSellers, ref: true, fieldNames: ['seller_id', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_sellers1_idx' })
  seller!: Ref<ProductSellers>;

  @Property({ unsigned: true, persist: false })
  sellerId!: number;

  @Property({ unsigned: true, persist: false, index: 'product_id_idx' })
  productId!: number;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  singularPrice!: string;

  @Property({ type: 'integer', unsigned: true })
  quantitySold: number & Opt = 1;

  @ManyToOne({ entity: () => ProductCountryMap, ref: true, fieldNames: ['country', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_country_map1_idx' })
  productCountryMap!: Ref<ProductCountryMap>;

}
",
  "import { Collection, Entity, ManyToMany, OneToMany, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

@Entity()
export class Sellers {

  [PrimaryKeyProp]?: 'sellerId';

  @PrimaryKey()
  sellerId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_sellers', pivotEntity: () => ProductSellers, joinColumn: 'seller_id', inverseJoinColumn: 'product_id' })
  productSellers = new Collection<Products>(this);

  @OneToMany({ entity: () => ProductSellers, mappedBy: 'seller' })
  productSellersCollection = new Collection<ProductSellers>(this);

}
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=always > bidirectionalRelations=true > identifiedReferences=true > entitySchema=true > dump 1`] = `
[
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

export class Countries {
  [PrimaryKeyProp]?: 'code';
  code!: string;
  productCountryMapCollection = new Collection<ProductCountryMap>(this);
  productCountryMapInverse = new Collection<Products>(this);
}

export const CountriesSchema = new EntitySchema({
  class: Countries,
  properties: {
    code: { primary: true, type: 'character', length: 2 },
    productCountryMapCollection: {
      kind: '1:m',
      entity: () => ProductCountryMap,
      mappedBy: 'countries',
    },
    productCountryMapInverse: {
      kind: 'm:n',
      entity: () => Products,
      mappedBy: 'productCountryMap',
    },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';
import { Sales } from './Sales';

export class ProductCountryMap {
  [PrimaryKeyProp]?: ['product', 'countries'];
  country!: string;
  product!: Ref<Products>;
  productId!: number;
  isCurrentlyAllowed: boolean & Opt = false;
  countries!: Ref<Countries>;
  salesCollection = new Collection<Sales>(this);
}

export const ProductCountryMapSchema = new EntitySchema({
  class: ProductCountryMap,
  indexes: [
    {
      name: 'full_idx',
      properties: ['countries', 'productId', 'isCurrentlyAllowed'],
    },
    { name: 'primary_reindex_idx', properties: ['countries', 'productId'] },
  ],
  properties: {
    country: { type: 'character', length: 2, persist: false },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      ref: true,
      fieldName: 'product_id',
      index: 'fk_product_country_map_products1',
    },
    productId: {
      type: 'integer',
      unsigned: true,
      persist: false,
      index: 'fk_product_country_map_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
    countries: {
      primary: true,
      kind: 'm:1',
      entity: () => Countries,
      ref: true,
      fieldName: 'country',
    },
    salesCollection: {
      kind: '1:m',
      entity: () => Sales,
      mappedBy: 'productCountryMap',
    },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { Products } from './Products';
import { Sales } from './Sales';
import { Sellers } from './Sellers';

export class ProductSellers {
  [PrimaryKeyProp]?: ['seller', 'product'];
  seller!: Ref<Sellers>;
  sellerId!: number;
  product!: Ref<Products>;
  productId!: number;
  isCurrentlyAllowed: boolean & Opt = false;
  salesCollection = new Collection<Sales>(this);
}

export const ProductSellersSchema = new EntitySchema({
  class: ProductSellers,
  properties: {
    seller: {
      primary: true,
      kind: 'm:1',
      entity: () => Sellers,
      ref: true,
      fieldName: 'seller_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    sellerId: { type: 'integer', unsigned: true, persist: false },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      ref: true,
      fieldName: 'product_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
      index: 'fk_product_sellers_products1',
    },
    productId: {
      type: 'integer',
      unsigned: true,
      persist: false,
      index: 'fk_product_sellers_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
    salesCollection: { kind: '1:m', entity: () => Sales, mappedBy: 'seller' },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';
import { Sellers } from './Sellers';

export class Products {
  [PrimaryKeyProp]?: 'productId';
  productId!: number;
  name!: string;
  currentPrice!: string;
  currentQuantity: number & Opt = 0;
  productCountryMap = new Collection<Countries>(this);
  productCountryMapCollection = new Collection<ProductCountryMap>(this);
  productSellersCollection = new Collection<ProductSellers>(this);
  productSellersInverse = new Collection<Sellers>(this);
}

export const ProductsSchema = new EntitySchema({
  class: Products,
  properties: {
    productId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    currentPrice: { type: 'decimal', precision: 10, scale: 2 },
    currentQuantity: { type: 'integer' },
    productCountryMap: {
      kind: 'm:n',
      entity: () => Countries,
      pivotTable: 'product_country_map',
      pivotEntity: () => ProductCountryMap,
      joinColumn: 'product_id',
      inverseJoinColumn: 'country',
    },
    productCountryMapCollection: {
      kind: '1:m',
      entity: () => ProductCountryMap,
      mappedBy: 'product',
    },
    productSellersCollection: {
      kind: '1:m',
      entity: () => ProductSellers,
      mappedBy: 'product',
    },
    productSellersInverse: {
      kind: 'm:n',
      entity: () => Sellers,
      mappedBy: 'productSellers',
    },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

export class Sales {
  [PrimaryKeyProp]?: 'saleId';
  saleId!: number;
  country!: string;
  seller!: Ref<ProductSellers>;
  sellerId!: number;
  productId!: number;
  singularPrice!: string;
  quantitySold: number & Opt = 1;
  productCountryMap!: Ref<ProductCountryMap>;
}

export const SalesSchema = new EntitySchema({
  class: Sales,
  properties: {
    saleId: { primary: true, type: 'integer' },
    country: { type: 'character', length: 2, persist: false },
    seller: {
      kind: 'm:1',
      entity: () => ProductSellers,
      ref: true,
      fieldNames: ['seller_id', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_sellers1_idx',
    },
    sellerId: { type: 'integer', unsigned: true, persist: false },
    productId: {
      type: 'integer',
      unsigned: true,
      persist: false,
      index: 'product_id_idx',
    },
    singularPrice: { type: 'decimal', precision: 10, scale: 2 },
    quantitySold: { type: 'integer', unsigned: true },
    productCountryMap: {
      kind: 'm:1',
      entity: () => ProductCountryMap,
      ref: true,
      fieldNames: ['country', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_country_map1_idx',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

export class Sellers {
  [PrimaryKeyProp]?: 'sellerId';
  sellerId!: number;
  name!: string;
  productSellers = new Collection<Products>(this);
  productSellersCollection = new Collection<ProductSellers>(this);
}

export const SellersSchema = new EntitySchema({
  class: Sellers,
  properties: {
    sellerId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    productSellers: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_sellers',
      pivotEntity: () => ProductSellers,
      joinColumn: 'seller_id',
      inverseJoinColumn: 'product_id',
    },
    productSellersCollection: {
      kind: '1:m',
      entity: () => ProductSellers,
      mappedBy: 'seller',
    },
  },
});
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=never > bidirectionalRelations=false > identifiedReferences=false > entitySchema=false > dump 1`] = `
[
  "import { Collection, Entity, ManyToMany, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

@Entity()
export class Countries {

  [PrimaryKeyProp]?: 'code';

  @PrimaryKey({ type: 'character', length: 2 })
  code!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_country_map', pivotEntity: () => ProductCountryMap, joinColumn: 'country', inverseJoinColumn: 'product_id' })
  productCountryMap = new Collection<Products>(this);

}
",
  "import { Entity, Index, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';

@Entity()
@Index({ name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] })
@Index({ name: 'primary_reindex_idx', properties: ['country', 'product'] })
export class ProductCountryMap {

  [PrimaryKeyProp]?: ['country', 'product'];

  @ManyToOne({ entity: () => Countries, fieldName: 'country', primary: true })
  country!: Countries;

  @ManyToOne({ entity: () => Products, fieldName: 'product_id', primary: true, index: 'fk_product_country_map_products1' })
  product!: Products;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Products } from './Products';
import { Sellers } from './Sellers';

@Entity()
export class ProductSellers {

  [PrimaryKeyProp]?: ['seller', 'product'];

  @ManyToOne({ entity: () => Sellers, fieldName: 'seller_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  seller!: Sellers;

  @ManyToOne({ entity: () => Products, fieldName: 'product_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true, index: 'fk_product_sellers_products1' })
  product!: Products;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

}
",
  "import { Entity, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';

@Entity()
export class Products {

  [PrimaryKeyProp]?: 'productId';

  @PrimaryKey()
  productId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  currentPrice!: string;

  @Property({ type: 'integer' })
  currentQuantity: number & Opt = 0;

}
",
  "import { Entity, Index, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

@Entity()
@Index({ name: 'product_id_idx', expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)' })
export class Sales {

  [PrimaryKeyProp]?: 'saleId';

  @PrimaryKey()
  saleId!: number;

  @ManyToOne({ entity: () => ProductCountryMap, fieldNames: ['country', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_country_map1_idx' })
  country!: ProductCountryMap;

  @ManyToOne({ entity: () => ProductSellers, fieldNames: ['seller_id', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_sellers1_idx' })
  seller!: ProductSellers;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  singularPrice!: string;

  @Property({ type: 'integer', unsigned: true })
  quantitySold: number & Opt = 1;

}
",
  "import { Collection, Entity, ManyToMany, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

@Entity()
export class Sellers {

  [PrimaryKeyProp]?: 'sellerId';

  @PrimaryKey()
  sellerId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_sellers', pivotEntity: () => ProductSellers, joinColumn: 'seller_id', inverseJoinColumn: 'product_id' })
  productSellers = new Collection<Products>(this);

}
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=never > bidirectionalRelations=false > identifiedReferences=false > entitySchema=true > dump 1`] = `
[
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

export class Countries {
  [PrimaryKeyProp]?: 'code';
  code!: string;
  productCountryMap = new Collection<Products>(this);
}

export const CountriesSchema = new EntitySchema({
  class: Countries,
  properties: {
    code: { primary: true, type: 'character', length: 2 },
    productCountryMap: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_country_map',
      pivotEntity: () => ProductCountryMap,
      joinColumn: 'country',
      inverseJoinColumn: 'product_id',
    },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';

export class ProductCountryMap {
  [PrimaryKeyProp]?: ['country', 'product'];
  country!: Countries;
  product!: Products;
  isCurrentlyAllowed: boolean & Opt = false;
}

export const ProductCountryMapSchema = new EntitySchema({
  class: ProductCountryMap,
  indexes: [
    { name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] },
    { name: 'primary_reindex_idx', properties: ['country', 'product'] },
  ],
  properties: {
    country: {
      primary: true,
      kind: 'm:1',
      entity: () => Countries,
      fieldName: 'country',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      fieldName: 'product_id',
      index: 'fk_product_country_map_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Products } from './Products';
import { Sellers } from './Sellers';

export class ProductSellers {
  [PrimaryKeyProp]?: ['seller', 'product'];
  seller!: Sellers;
  product!: Products;
  isCurrentlyAllowed: boolean & Opt = false;
}

export const ProductSellersSchema = new EntitySchema({
  class: ProductSellers,
  properties: {
    seller: {
      primary: true,
      kind: 'm:1',
      entity: () => Sellers,
      fieldName: 'seller_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      fieldName: 'product_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
      index: 'fk_product_sellers_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';

export class Products {
  [PrimaryKeyProp]?: 'productId';
  productId!: number;
  name!: string;
  currentPrice!: string;
  currentQuantity: number & Opt = 0;
}

export const ProductsSchema = new EntitySchema({
  class: Products,
  properties: {
    productId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    currentPrice: { type: 'decimal', precision: 10, scale: 2 },
    currentQuantity: { type: 'integer' },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

export class Sales {
  [PrimaryKeyProp]?: 'saleId';
  saleId!: number;
  country!: ProductCountryMap;
  seller!: ProductSellers;
  singularPrice!: string;
  quantitySold: number & Opt = 1;
}

export const SalesSchema = new EntitySchema({
  class: Sales,
  indexes: [
    {
      name: 'product_id_idx',
      expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)',
    },
  ],
  properties: {
    saleId: { primary: true, type: 'integer' },
    country: {
      kind: 'm:1',
      entity: () => ProductCountryMap,
      fieldNames: ['country', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_country_map1_idx',
    },
    seller: {
      kind: 'm:1',
      entity: () => ProductSellers,
      fieldNames: ['seller_id', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_sellers1_idx',
    },
    singularPrice: { type: 'decimal', precision: 10, scale: 2 },
    quantitySold: { type: 'integer', unsigned: true },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

export class Sellers {
  [PrimaryKeyProp]?: 'sellerId';
  sellerId!: number;
  name!: string;
  productSellers = new Collection<Products>(this);
}

export const SellersSchema = new EntitySchema({
  class: Sellers,
  properties: {
    sellerId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    productSellers: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_sellers',
      pivotEntity: () => ProductSellers,
      joinColumn: 'seller_id',
      inverseJoinColumn: 'product_id',
    },
  },
});
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=never > bidirectionalRelations=false > identifiedReferences=true > entitySchema=false > dump 1`] = `
[
  "import { Collection, Entity, ManyToMany, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

@Entity()
export class Countries {

  [PrimaryKeyProp]?: 'code';

  @PrimaryKey({ type: 'character', length: 2 })
  code!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_country_map', pivotEntity: () => ProductCountryMap, joinColumn: 'country', inverseJoinColumn: 'product_id' })
  productCountryMap = new Collection<Products>(this);

}
",
  "import { Entity, Index, ManyToOne, type Opt, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';

@Entity()
@Index({ name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] })
@Index({ name: 'primary_reindex_idx', properties: ['country', 'product'] })
export class ProductCountryMap {

  [PrimaryKeyProp]?: ['country', 'product'];

  @ManyToOne({ entity: () => Countries, ref: true, fieldName: 'country', primary: true })
  country!: Ref<Countries>;

  @ManyToOne({ entity: () => Products, ref: true, fieldName: 'product_id', primary: true, index: 'fk_product_country_map_products1' })
  product!: Ref<Products>;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { Products } from './Products';
import { Sellers } from './Sellers';

@Entity()
export class ProductSellers {

  [PrimaryKeyProp]?: ['seller', 'product'];

  @ManyToOne({ entity: () => Sellers, ref: true, fieldName: 'seller_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  seller!: Ref<Sellers>;

  @ManyToOne({ entity: () => Products, ref: true, fieldName: 'product_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true, index: 'fk_product_sellers_products1' })
  product!: Ref<Products>;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

}
",
  "import { Entity, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';

@Entity()
export class Products {

  [PrimaryKeyProp]?: 'productId';

  @PrimaryKey()
  productId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  currentPrice!: string;

  @Property({ type: 'integer' })
  currentQuantity: number & Opt = 0;

}
",
  "import { Entity, Index, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

@Entity()
@Index({ name: 'product_id_idx', expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)' })
export class Sales {

  [PrimaryKeyProp]?: 'saleId';

  @PrimaryKey()
  saleId!: number;

  @ManyToOne({ entity: () => ProductCountryMap, ref: true, fieldNames: ['country', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_country_map1_idx' })
  country!: Ref<ProductCountryMap>;

  @ManyToOne({ entity: () => ProductSellers, ref: true, fieldNames: ['seller_id', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_sellers1_idx' })
  seller!: Ref<ProductSellers>;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  singularPrice!: string;

  @Property({ type: 'integer', unsigned: true })
  quantitySold: number & Opt = 1;

}
",
  "import { Collection, Entity, ManyToMany, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

@Entity()
export class Sellers {

  [PrimaryKeyProp]?: 'sellerId';

  @PrimaryKey()
  sellerId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_sellers', pivotEntity: () => ProductSellers, joinColumn: 'seller_id', inverseJoinColumn: 'product_id' })
  productSellers = new Collection<Products>(this);

}
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=never > bidirectionalRelations=false > identifiedReferences=true > entitySchema=true > dump 1`] = `
[
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

export class Countries {
  [PrimaryKeyProp]?: 'code';
  code!: string;
  productCountryMap = new Collection<Products>(this);
}

export const CountriesSchema = new EntitySchema({
  class: Countries,
  properties: {
    code: { primary: true, type: 'character', length: 2 },
    productCountryMap: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_country_map',
      pivotEntity: () => ProductCountryMap,
      joinColumn: 'country',
      inverseJoinColumn: 'product_id',
    },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';

export class ProductCountryMap {
  [PrimaryKeyProp]?: ['country', 'product'];
  country!: Ref<Countries>;
  product!: Ref<Products>;
  isCurrentlyAllowed: boolean & Opt = false;
}

export const ProductCountryMapSchema = new EntitySchema({
  class: ProductCountryMap,
  indexes: [
    { name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] },
    { name: 'primary_reindex_idx', properties: ['country', 'product'] },
  ],
  properties: {
    country: {
      primary: true,
      kind: 'm:1',
      entity: () => Countries,
      ref: true,
      fieldName: 'country',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      ref: true,
      fieldName: 'product_id',
      index: 'fk_product_country_map_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { Products } from './Products';
import { Sellers } from './Sellers';

export class ProductSellers {
  [PrimaryKeyProp]?: ['seller', 'product'];
  seller!: Ref<Sellers>;
  product!: Ref<Products>;
  isCurrentlyAllowed: boolean & Opt = false;
}

export const ProductSellersSchema = new EntitySchema({
  class: ProductSellers,
  properties: {
    seller: {
      primary: true,
      kind: 'm:1',
      entity: () => Sellers,
      ref: true,
      fieldName: 'seller_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      ref: true,
      fieldName: 'product_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
      index: 'fk_product_sellers_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';

export class Products {
  [PrimaryKeyProp]?: 'productId';
  productId!: number;
  name!: string;
  currentPrice!: string;
  currentQuantity: number & Opt = 0;
}

export const ProductsSchema = new EntitySchema({
  class: Products,
  properties: {
    productId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    currentPrice: { type: 'decimal', precision: 10, scale: 2 },
    currentQuantity: { type: 'integer' },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

export class Sales {
  [PrimaryKeyProp]?: 'saleId';
  saleId!: number;
  country!: Ref<ProductCountryMap>;
  seller!: Ref<ProductSellers>;
  singularPrice!: string;
  quantitySold: number & Opt = 1;
}

export const SalesSchema = new EntitySchema({
  class: Sales,
  indexes: [
    {
      name: 'product_id_idx',
      expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)',
    },
  ],
  properties: {
    saleId: { primary: true, type: 'integer' },
    country: {
      kind: 'm:1',
      entity: () => ProductCountryMap,
      ref: true,
      fieldNames: ['country', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_country_map1_idx',
    },
    seller: {
      kind: 'm:1',
      entity: () => ProductSellers,
      ref: true,
      fieldNames: ['seller_id', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_sellers1_idx',
    },
    singularPrice: { type: 'decimal', precision: 10, scale: 2 },
    quantitySold: { type: 'integer', unsigned: true },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

export class Sellers {
  [PrimaryKeyProp]?: 'sellerId';
  sellerId!: number;
  name!: string;
  productSellers = new Collection<Products>(this);
}

export const SellersSchema = new EntitySchema({
  class: Sellers,
  properties: {
    sellerId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    productSellers: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_sellers',
      pivotEntity: () => ProductSellers,
      joinColumn: 'seller_id',
      inverseJoinColumn: 'product_id',
    },
  },
});
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=never > bidirectionalRelations=true > identifiedReferences=false > entitySchema=false > dump 1`] = `
[
  "import { Collection, Entity, ManyToMany, OneToMany, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

@Entity()
export class Countries {

  [PrimaryKeyProp]?: 'code';

  @PrimaryKey({ type: 'character', length: 2 })
  code!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_country_map', pivotEntity: () => ProductCountryMap, joinColumn: 'country', inverseJoinColumn: 'product_id' })
  productCountryMap = new Collection<Products>(this);

  @OneToMany({ entity: () => ProductCountryMap, mappedBy: 'country' })
  productCountryMapCollection = new Collection<ProductCountryMap>(this);

}
",
  "import { Collection, Entity, Index, ManyToOne, OneToMany, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';
import { Sales } from './Sales';

@Entity()
@Index({ name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] })
@Index({ name: 'primary_reindex_idx', properties: ['country', 'product'] })
export class ProductCountryMap {

  [PrimaryKeyProp]?: ['country', 'product'];

  @ManyToOne({ entity: () => Countries, fieldName: 'country', primary: true })
  country!: Countries;

  @ManyToOne({ entity: () => Products, fieldName: 'product_id', primary: true, index: 'fk_product_country_map_products1' })
  product!: Products;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

  @OneToMany({ entity: () => Sales, mappedBy: 'country' })
  salesCollection = new Collection<Sales>(this);

}
",
  "import { Collection, Entity, ManyToOne, OneToMany, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Products } from './Products';
import { Sales } from './Sales';
import { Sellers } from './Sellers';

@Entity()
export class ProductSellers {

  [PrimaryKeyProp]?: ['seller', 'product'];

  @ManyToOne({ entity: () => Sellers, fieldName: 'seller_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  seller!: Sellers;

  @ManyToOne({ entity: () => Products, fieldName: 'product_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true, index: 'fk_product_sellers_products1' })
  product!: Products;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

  @OneToMany({ entity: () => Sales, mappedBy: 'seller' })
  salesCollection = new Collection<Sales>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToMany, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';
import { Sellers } from './Sellers';

@Entity()
export class Products {

  [PrimaryKeyProp]?: 'productId';

  @PrimaryKey()
  productId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  currentPrice!: string;

  @Property({ type: 'integer' })
  currentQuantity: number & Opt = 0;

  @ManyToMany({ entity: () => Countries, mappedBy: 'productCountryMap' })
  productCountryMapInverse = new Collection<Countries>(this);

  @OneToMany({ entity: () => ProductCountryMap, mappedBy: 'product' })
  productCountryMapCollection = new Collection<ProductCountryMap>(this);

  @OneToMany({ entity: () => ProductSellers, mappedBy: 'product' })
  productSellersCollection = new Collection<ProductSellers>(this);

  @ManyToMany({ entity: () => Sellers, mappedBy: 'productSellers' })
  productSellersInverse = new Collection<Sellers>(this);

}
",
  "import { Entity, Index, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

@Entity()
@Index({ name: 'product_id_idx', expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)' })
export class Sales {

  [PrimaryKeyProp]?: 'saleId';

  @PrimaryKey()
  saleId!: number;

  @ManyToOne({ entity: () => ProductCountryMap, fieldNames: ['country', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_country_map1_idx' })
  country!: ProductCountryMap;

  @ManyToOne({ entity: () => ProductSellers, fieldNames: ['seller_id', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_sellers1_idx' })
  seller!: ProductSellers;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  singularPrice!: string;

  @Property({ type: 'integer', unsigned: true })
  quantitySold: number & Opt = 1;

}
",
  "import { Collection, Entity, ManyToMany, OneToMany, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

@Entity()
export class Sellers {

  [PrimaryKeyProp]?: 'sellerId';

  @PrimaryKey()
  sellerId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_sellers', pivotEntity: () => ProductSellers, joinColumn: 'seller_id', inverseJoinColumn: 'product_id' })
  productSellers = new Collection<Products>(this);

  @OneToMany({ entity: () => ProductSellers, mappedBy: 'seller' })
  productSellersCollection = new Collection<ProductSellers>(this);

}
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=never > bidirectionalRelations=true > identifiedReferences=false > entitySchema=true > dump 1`] = `
[
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

export class Countries {
  [PrimaryKeyProp]?: 'code';
  code!: string;
  productCountryMap = new Collection<Products>(this);
  productCountryMapCollection = new Collection<ProductCountryMap>(this);
}

export const CountriesSchema = new EntitySchema({
  class: Countries,
  properties: {
    code: { primary: true, type: 'character', length: 2 },
    productCountryMap: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_country_map',
      pivotEntity: () => ProductCountryMap,
      joinColumn: 'country',
      inverseJoinColumn: 'product_id',
    },
    productCountryMapCollection: {
      kind: '1:m',
      entity: () => ProductCountryMap,
      mappedBy: 'country',
    },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';
import { Sales } from './Sales';

export class ProductCountryMap {
  [PrimaryKeyProp]?: ['country', 'product'];
  country!: Countries;
  product!: Products;
  isCurrentlyAllowed: boolean & Opt = false;
  salesCollection = new Collection<Sales>(this);
}

export const ProductCountryMapSchema = new EntitySchema({
  class: ProductCountryMap,
  indexes: [
    { name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] },
    { name: 'primary_reindex_idx', properties: ['country', 'product'] },
  ],
  properties: {
    country: {
      primary: true,
      kind: 'm:1',
      entity: () => Countries,
      fieldName: 'country',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      fieldName: 'product_id',
      index: 'fk_product_country_map_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
    salesCollection: { kind: '1:m', entity: () => Sales, mappedBy: 'country' },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Products } from './Products';
import { Sales } from './Sales';
import { Sellers } from './Sellers';

export class ProductSellers {
  [PrimaryKeyProp]?: ['seller', 'product'];
  seller!: Sellers;
  product!: Products;
  isCurrentlyAllowed: boolean & Opt = false;
  salesCollection = new Collection<Sales>(this);
}

export const ProductSellersSchema = new EntitySchema({
  class: ProductSellers,
  properties: {
    seller: {
      primary: true,
      kind: 'm:1',
      entity: () => Sellers,
      fieldName: 'seller_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      fieldName: 'product_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
      index: 'fk_product_sellers_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
    salesCollection: { kind: '1:m', entity: () => Sales, mappedBy: 'seller' },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';
import { Sellers } from './Sellers';

export class Products {
  [PrimaryKeyProp]?: 'productId';
  productId!: number;
  name!: string;
  currentPrice!: string;
  currentQuantity: number & Opt = 0;
  productCountryMapInverse = new Collection<Countries>(this);
  productCountryMapCollection = new Collection<ProductCountryMap>(this);
  productSellersCollection = new Collection<ProductSellers>(this);
  productSellersInverse = new Collection<Sellers>(this);
}

export const ProductsSchema = new EntitySchema({
  class: Products,
  properties: {
    productId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    currentPrice: { type: 'decimal', precision: 10, scale: 2 },
    currentQuantity: { type: 'integer' },
    productCountryMapInverse: {
      kind: 'm:n',
      entity: () => Countries,
      mappedBy: 'productCountryMap',
    },
    productCountryMapCollection: {
      kind: '1:m',
      entity: () => ProductCountryMap,
      mappedBy: 'product',
    },
    productSellersCollection: {
      kind: '1:m',
      entity: () => ProductSellers,
      mappedBy: 'product',
    },
    productSellersInverse: {
      kind: 'm:n',
      entity: () => Sellers,
      mappedBy: 'productSellers',
    },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

export class Sales {
  [PrimaryKeyProp]?: 'saleId';
  saleId!: number;
  country!: ProductCountryMap;
  seller!: ProductSellers;
  singularPrice!: string;
  quantitySold: number & Opt = 1;
}

export const SalesSchema = new EntitySchema({
  class: Sales,
  indexes: [
    {
      name: 'product_id_idx',
      expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)',
    },
  ],
  properties: {
    saleId: { primary: true, type: 'integer' },
    country: {
      kind: 'm:1',
      entity: () => ProductCountryMap,
      fieldNames: ['country', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_country_map1_idx',
    },
    seller: {
      kind: 'm:1',
      entity: () => ProductSellers,
      fieldNames: ['seller_id', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_sellers1_idx',
    },
    singularPrice: { type: 'decimal', precision: 10, scale: 2 },
    quantitySold: { type: 'integer', unsigned: true },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

export class Sellers {
  [PrimaryKeyProp]?: 'sellerId';
  sellerId!: number;
  name!: string;
  productSellers = new Collection<Products>(this);
  productSellersCollection = new Collection<ProductSellers>(this);
}

export const SellersSchema = new EntitySchema({
  class: Sellers,
  properties: {
    sellerId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    productSellers: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_sellers',
      pivotEntity: () => ProductSellers,
      joinColumn: 'seller_id',
      inverseJoinColumn: 'product_id',
    },
    productSellersCollection: {
      kind: '1:m',
      entity: () => ProductSellers,
      mappedBy: 'seller',
    },
  },
});
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=never > bidirectionalRelations=true > identifiedReferences=true > entitySchema=false > dump 1`] = `
[
  "import { Collection, Entity, ManyToMany, OneToMany, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

@Entity()
export class Countries {

  [PrimaryKeyProp]?: 'code';

  @PrimaryKey({ type: 'character', length: 2 })
  code!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_country_map', pivotEntity: () => ProductCountryMap, joinColumn: 'country', inverseJoinColumn: 'product_id' })
  productCountryMap = new Collection<Products>(this);

  @OneToMany({ entity: () => ProductCountryMap, mappedBy: 'country' })
  productCountryMapCollection = new Collection<ProductCountryMap>(this);

}
",
  "import { Collection, Entity, Index, ManyToOne, OneToMany, type Opt, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';
import { Sales } from './Sales';

@Entity()
@Index({ name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] })
@Index({ name: 'primary_reindex_idx', properties: ['country', 'product'] })
export class ProductCountryMap {

  [PrimaryKeyProp]?: ['country', 'product'];

  @ManyToOne({ entity: () => Countries, ref: true, fieldName: 'country', primary: true })
  country!: Ref<Countries>;

  @ManyToOne({ entity: () => Products, ref: true, fieldName: 'product_id', primary: true, index: 'fk_product_country_map_products1' })
  product!: Ref<Products>;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

  @OneToMany({ entity: () => Sales, mappedBy: 'country' })
  salesCollection = new Collection<Sales>(this);

}
",
  "import { Collection, Entity, ManyToOne, OneToMany, type Opt, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { Products } from './Products';
import { Sales } from './Sales';
import { Sellers } from './Sellers';

@Entity()
export class ProductSellers {

  [PrimaryKeyProp]?: ['seller', 'product'];

  @ManyToOne({ entity: () => Sellers, ref: true, fieldName: 'seller_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  seller!: Ref<Sellers>;

  @ManyToOne({ entity: () => Products, ref: true, fieldName: 'product_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true, index: 'fk_product_sellers_products1' })
  product!: Ref<Products>;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

  @OneToMany({ entity: () => Sales, mappedBy: 'seller' })
  salesCollection = new Collection<Sales>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToMany, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';
import { Sellers } from './Sellers';

@Entity()
export class Products {

  [PrimaryKeyProp]?: 'productId';

  @PrimaryKey()
  productId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  currentPrice!: string;

  @Property({ type: 'integer' })
  currentQuantity: number & Opt = 0;

  @ManyToMany({ entity: () => Countries, mappedBy: 'productCountryMap' })
  productCountryMapInverse = new Collection<Countries>(this);

  @OneToMany({ entity: () => ProductCountryMap, mappedBy: 'product' })
  productCountryMapCollection = new Collection<ProductCountryMap>(this);

  @OneToMany({ entity: () => ProductSellers, mappedBy: 'product' })
  productSellersCollection = new Collection<ProductSellers>(this);

  @ManyToMany({ entity: () => Sellers, mappedBy: 'productSellers' })
  productSellersInverse = new Collection<Sellers>(this);

}
",
  "import { Entity, Index, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

@Entity()
@Index({ name: 'product_id_idx', expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)' })
export class Sales {

  [PrimaryKeyProp]?: 'saleId';

  @PrimaryKey()
  saleId!: number;

  @ManyToOne({ entity: () => ProductCountryMap, ref: true, fieldNames: ['country', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_country_map1_idx' })
  country!: Ref<ProductCountryMap>;

  @ManyToOne({ entity: () => ProductSellers, ref: true, fieldNames: ['seller_id', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_sellers1_idx' })
  seller!: Ref<ProductSellers>;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  singularPrice!: string;

  @Property({ type: 'integer', unsigned: true })
  quantitySold: number & Opt = 1;

}
",
  "import { Collection, Entity, ManyToMany, OneToMany, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

@Entity()
export class Sellers {

  [PrimaryKeyProp]?: 'sellerId';

  @PrimaryKey()
  sellerId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_sellers', pivotEntity: () => ProductSellers, joinColumn: 'seller_id', inverseJoinColumn: 'product_id' })
  productSellers = new Collection<Products>(this);

  @OneToMany({ entity: () => ProductSellers, mappedBy: 'seller' })
  productSellersCollection = new Collection<ProductSellers>(this);

}
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=never > bidirectionalRelations=true > identifiedReferences=true > entitySchema=true > dump 1`] = `
[
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

export class Countries {
  [PrimaryKeyProp]?: 'code';
  code!: string;
  productCountryMap = new Collection<Products>(this);
  productCountryMapCollection = new Collection<ProductCountryMap>(this);
}

export const CountriesSchema = new EntitySchema({
  class: Countries,
  properties: {
    code: { primary: true, type: 'character', length: 2 },
    productCountryMap: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_country_map',
      pivotEntity: () => ProductCountryMap,
      joinColumn: 'country',
      inverseJoinColumn: 'product_id',
    },
    productCountryMapCollection: {
      kind: '1:m',
      entity: () => ProductCountryMap,
      mappedBy: 'country',
    },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';
import { Sales } from './Sales';

export class ProductCountryMap {
  [PrimaryKeyProp]?: ['country', 'product'];
  country!: Ref<Countries>;
  product!: Ref<Products>;
  isCurrentlyAllowed: boolean & Opt = false;
  salesCollection = new Collection<Sales>(this);
}

export const ProductCountryMapSchema = new EntitySchema({
  class: ProductCountryMap,
  indexes: [
    { name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] },
    { name: 'primary_reindex_idx', properties: ['country', 'product'] },
  ],
  properties: {
    country: {
      primary: true,
      kind: 'm:1',
      entity: () => Countries,
      ref: true,
      fieldName: 'country',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      ref: true,
      fieldName: 'product_id',
      index: 'fk_product_country_map_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
    salesCollection: { kind: '1:m', entity: () => Sales, mappedBy: 'country' },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { Products } from './Products';
import { Sales } from './Sales';
import { Sellers } from './Sellers';

export class ProductSellers {
  [PrimaryKeyProp]?: ['seller', 'product'];
  seller!: Ref<Sellers>;
  product!: Ref<Products>;
  isCurrentlyAllowed: boolean & Opt = false;
  salesCollection = new Collection<Sales>(this);
}

export const ProductSellersSchema = new EntitySchema({
  class: ProductSellers,
  properties: {
    seller: {
      primary: true,
      kind: 'm:1',
      entity: () => Sellers,
      ref: true,
      fieldName: 'seller_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      ref: true,
      fieldName: 'product_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
      index: 'fk_product_sellers_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
    salesCollection: { kind: '1:m', entity: () => Sales, mappedBy: 'seller' },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';
import { Sellers } from './Sellers';

export class Products {
  [PrimaryKeyProp]?: 'productId';
  productId!: number;
  name!: string;
  currentPrice!: string;
  currentQuantity: number & Opt = 0;
  productCountryMapInverse = new Collection<Countries>(this);
  productCountryMapCollection = new Collection<ProductCountryMap>(this);
  productSellersCollection = new Collection<ProductSellers>(this);
  productSellersInverse = new Collection<Sellers>(this);
}

export const ProductsSchema = new EntitySchema({
  class: Products,
  properties: {
    productId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    currentPrice: { type: 'decimal', precision: 10, scale: 2 },
    currentQuantity: { type: 'integer' },
    productCountryMapInverse: {
      kind: 'm:n',
      entity: () => Countries,
      mappedBy: 'productCountryMap',
    },
    productCountryMapCollection: {
      kind: '1:m',
      entity: () => ProductCountryMap,
      mappedBy: 'product',
    },
    productSellersCollection: {
      kind: '1:m',
      entity: () => ProductSellers,
      mappedBy: 'product',
    },
    productSellersInverse: {
      kind: 'm:n',
      entity: () => Sellers,
      mappedBy: 'productSellers',
    },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

export class Sales {
  [PrimaryKeyProp]?: 'saleId';
  saleId!: number;
  country!: Ref<ProductCountryMap>;
  seller!: Ref<ProductSellers>;
  singularPrice!: string;
  quantitySold: number & Opt = 1;
}

export const SalesSchema = new EntitySchema({
  class: Sales,
  indexes: [
    {
      name: 'product_id_idx',
      expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)',
    },
  ],
  properties: {
    saleId: { primary: true, type: 'integer' },
    country: {
      kind: 'm:1',
      entity: () => ProductCountryMap,
      ref: true,
      fieldNames: ['country', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_country_map1_idx',
    },
    seller: {
      kind: 'm:1',
      entity: () => ProductSellers,
      ref: true,
      fieldNames: ['seller_id', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_sellers1_idx',
    },
    singularPrice: { type: 'decimal', precision: 10, scale: 2 },
    quantitySold: { type: 'integer', unsigned: true },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

export class Sellers {
  [PrimaryKeyProp]?: 'sellerId';
  sellerId!: number;
  name!: string;
  productSellers = new Collection<Products>(this);
  productSellersCollection = new Collection<ProductSellers>(this);
}

export const SellersSchema = new EntitySchema({
  class: Sellers,
  properties: {
    sellerId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    productSellers: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_sellers',
      pivotEntity: () => ProductSellers,
      joinColumn: 'seller_id',
      inverseJoinColumn: 'product_id',
    },
    productSellersCollection: {
      kind: '1:m',
      entity: () => ProductSellers,
      mappedBy: 'seller',
    },
  },
});
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=smart > bidirectionalRelations=false > identifiedReferences=false > entitySchema=false > dump 1`] = `
[
  "import { Collection, Entity, ManyToMany, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

@Entity()
export class Countries {

  [PrimaryKeyProp]?: 'code';

  @PrimaryKey({ type: 'character', length: 2 })
  code!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_country_map', pivotEntity: () => ProductCountryMap, joinColumn: 'country', inverseJoinColumn: 'product_id' })
  productCountryMap = new Collection<Products>(this);

}
",
  "import { Entity, Index, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';

@Entity()
@Index({ name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] })
@Index({ name: 'primary_reindex_idx', properties: ['country', 'product'] })
export class ProductCountryMap {

  [PrimaryKeyProp]?: ['country', 'product'];

  @ManyToOne({ entity: () => Countries, fieldName: 'country', primary: true })
  country!: Countries;

  @ManyToOne({ entity: () => Products, fieldName: 'product_id', primary: true, index: 'fk_product_country_map_products1' })
  product!: Products;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Products } from './Products';
import { Sellers } from './Sellers';

@Entity()
export class ProductSellers {

  [PrimaryKeyProp]?: ['seller', 'product'];

  @ManyToOne({ entity: () => Sellers, fieldName: 'seller_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  seller!: Sellers;

  @ManyToOne({ entity: () => Products, fieldName: 'product_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true, index: 'fk_product_sellers_products1' })
  product!: Products;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

}
",
  "import { Entity, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';

@Entity()
export class Products {

  [PrimaryKeyProp]?: 'productId';

  @PrimaryKey()
  productId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  currentPrice!: string;

  @Property({ type: 'integer' })
  currentQuantity: number & Opt = 0;

}
",
  "import { Entity, Index, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

@Entity()
@Index({ name: 'product_id_idx', expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)' })
export class Sales {

  [PrimaryKeyProp]?: 'saleId';

  @PrimaryKey()
  saleId!: number;

  @ManyToOne({ entity: () => ProductCountryMap, fieldNames: ['country', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_country_map1_idx' })
  country!: ProductCountryMap;

  @ManyToOne({ entity: () => ProductSellers, fieldNames: ['seller_id', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_sellers1_idx' })
  seller!: ProductSellers;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  singularPrice!: string;

  @Property({ type: 'integer', unsigned: true })
  quantitySold: number & Opt = 1;

}
",
  "import { Collection, Entity, ManyToMany, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

@Entity()
export class Sellers {

  [PrimaryKeyProp]?: 'sellerId';

  @PrimaryKey()
  sellerId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_sellers', pivotEntity: () => ProductSellers, joinColumn: 'seller_id', inverseJoinColumn: 'product_id' })
  productSellers = new Collection<Products>(this);

}
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=smart > bidirectionalRelations=false > identifiedReferences=false > entitySchema=true > dump 1`] = `
[
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

export class Countries {
  [PrimaryKeyProp]?: 'code';
  code!: string;
  productCountryMap = new Collection<Products>(this);
}

export const CountriesSchema = new EntitySchema({
  class: Countries,
  properties: {
    code: { primary: true, type: 'character', length: 2 },
    productCountryMap: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_country_map',
      pivotEntity: () => ProductCountryMap,
      joinColumn: 'country',
      inverseJoinColumn: 'product_id',
    },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';

export class ProductCountryMap {
  [PrimaryKeyProp]?: ['country', 'product'];
  country!: Countries;
  product!: Products;
  isCurrentlyAllowed: boolean & Opt = false;
}

export const ProductCountryMapSchema = new EntitySchema({
  class: ProductCountryMap,
  indexes: [
    { name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] },
    { name: 'primary_reindex_idx', properties: ['country', 'product'] },
  ],
  properties: {
    country: {
      primary: true,
      kind: 'm:1',
      entity: () => Countries,
      fieldName: 'country',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      fieldName: 'product_id',
      index: 'fk_product_country_map_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Products } from './Products';
import { Sellers } from './Sellers';

export class ProductSellers {
  [PrimaryKeyProp]?: ['seller', 'product'];
  seller!: Sellers;
  product!: Products;
  isCurrentlyAllowed: boolean & Opt = false;
}

export const ProductSellersSchema = new EntitySchema({
  class: ProductSellers,
  properties: {
    seller: {
      primary: true,
      kind: 'm:1',
      entity: () => Sellers,
      fieldName: 'seller_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      fieldName: 'product_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
      index: 'fk_product_sellers_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';

export class Products {
  [PrimaryKeyProp]?: 'productId';
  productId!: number;
  name!: string;
  currentPrice!: string;
  currentQuantity: number & Opt = 0;
}

export const ProductsSchema = new EntitySchema({
  class: Products,
  properties: {
    productId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    currentPrice: { type: 'decimal', precision: 10, scale: 2 },
    currentQuantity: { type: 'integer' },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

export class Sales {
  [PrimaryKeyProp]?: 'saleId';
  saleId!: number;
  country!: ProductCountryMap;
  seller!: ProductSellers;
  singularPrice!: string;
  quantitySold: number & Opt = 1;
}

export const SalesSchema = new EntitySchema({
  class: Sales,
  indexes: [
    {
      name: 'product_id_idx',
      expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)',
    },
  ],
  properties: {
    saleId: { primary: true, type: 'integer' },
    country: {
      kind: 'm:1',
      entity: () => ProductCountryMap,
      fieldNames: ['country', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_country_map1_idx',
    },
    seller: {
      kind: 'm:1',
      entity: () => ProductSellers,
      fieldNames: ['seller_id', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_sellers1_idx',
    },
    singularPrice: { type: 'decimal', precision: 10, scale: 2 },
    quantitySold: { type: 'integer', unsigned: true },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

export class Sellers {
  [PrimaryKeyProp]?: 'sellerId';
  sellerId!: number;
  name!: string;
  productSellers = new Collection<Products>(this);
}

export const SellersSchema = new EntitySchema({
  class: Sellers,
  properties: {
    sellerId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    productSellers: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_sellers',
      pivotEntity: () => ProductSellers,
      joinColumn: 'seller_id',
      inverseJoinColumn: 'product_id',
    },
  },
});
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=smart > bidirectionalRelations=false > identifiedReferences=true > entitySchema=false > dump 1`] = `
[
  "import { Collection, Entity, ManyToMany, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

@Entity()
export class Countries {

  [PrimaryKeyProp]?: 'code';

  @PrimaryKey({ type: 'character', length: 2 })
  code!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_country_map', pivotEntity: () => ProductCountryMap, joinColumn: 'country', inverseJoinColumn: 'product_id' })
  productCountryMap = new Collection<Products>(this);

}
",
  "import { Entity, Index, ManyToOne, type Opt, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';

@Entity()
@Index({ name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] })
@Index({ name: 'primary_reindex_idx', properties: ['country', 'product'] })
export class ProductCountryMap {

  [PrimaryKeyProp]?: ['country', 'product'];

  @ManyToOne({ entity: () => Countries, ref: true, fieldName: 'country', primary: true })
  country!: Ref<Countries>;

  @ManyToOne({ entity: () => Products, ref: true, fieldName: 'product_id', primary: true, index: 'fk_product_country_map_products1' })
  product!: Ref<Products>;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { Products } from './Products';
import { Sellers } from './Sellers';

@Entity()
export class ProductSellers {

  [PrimaryKeyProp]?: ['seller', 'product'];

  @ManyToOne({ entity: () => Sellers, ref: true, fieldName: 'seller_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  seller!: Ref<Sellers>;

  @ManyToOne({ entity: () => Products, ref: true, fieldName: 'product_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true, index: 'fk_product_sellers_products1' })
  product!: Ref<Products>;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

}
",
  "import { Entity, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';

@Entity()
export class Products {

  [PrimaryKeyProp]?: 'productId';

  @PrimaryKey()
  productId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  currentPrice!: string;

  @Property({ type: 'integer' })
  currentQuantity: number & Opt = 0;

}
",
  "import { Entity, Index, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

@Entity()
@Index({ name: 'product_id_idx', expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)' })
export class Sales {

  [PrimaryKeyProp]?: 'saleId';

  @PrimaryKey()
  saleId!: number;

  @ManyToOne({ entity: () => ProductCountryMap, ref: true, fieldNames: ['country', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_country_map1_idx' })
  country!: Ref<ProductCountryMap>;

  @ManyToOne({ entity: () => ProductSellers, ref: true, fieldNames: ['seller_id', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_sellers1_idx' })
  seller!: Ref<ProductSellers>;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  singularPrice!: string;

  @Property({ type: 'integer', unsigned: true })
  quantitySold: number & Opt = 1;

}
",
  "import { Collection, Entity, ManyToMany, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

@Entity()
export class Sellers {

  [PrimaryKeyProp]?: 'sellerId';

  @PrimaryKey()
  sellerId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_sellers', pivotEntity: () => ProductSellers, joinColumn: 'seller_id', inverseJoinColumn: 'product_id' })
  productSellers = new Collection<Products>(this);

}
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=smart > bidirectionalRelations=false > identifiedReferences=true > entitySchema=true > dump 1`] = `
[
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

export class Countries {
  [PrimaryKeyProp]?: 'code';
  code!: string;
  productCountryMap = new Collection<Products>(this);
}

export const CountriesSchema = new EntitySchema({
  class: Countries,
  properties: {
    code: { primary: true, type: 'character', length: 2 },
    productCountryMap: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_country_map',
      pivotEntity: () => ProductCountryMap,
      joinColumn: 'country',
      inverseJoinColumn: 'product_id',
    },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';

export class ProductCountryMap {
  [PrimaryKeyProp]?: ['country', 'product'];
  country!: Ref<Countries>;
  product!: Ref<Products>;
  isCurrentlyAllowed: boolean & Opt = false;
}

export const ProductCountryMapSchema = new EntitySchema({
  class: ProductCountryMap,
  indexes: [
    { name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] },
    { name: 'primary_reindex_idx', properties: ['country', 'product'] },
  ],
  properties: {
    country: {
      primary: true,
      kind: 'm:1',
      entity: () => Countries,
      ref: true,
      fieldName: 'country',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      ref: true,
      fieldName: 'product_id',
      index: 'fk_product_country_map_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { Products } from './Products';
import { Sellers } from './Sellers';

export class ProductSellers {
  [PrimaryKeyProp]?: ['seller', 'product'];
  seller!: Ref<Sellers>;
  product!: Ref<Products>;
  isCurrentlyAllowed: boolean & Opt = false;
}

export const ProductSellersSchema = new EntitySchema({
  class: ProductSellers,
  properties: {
    seller: {
      primary: true,
      kind: 'm:1',
      entity: () => Sellers,
      ref: true,
      fieldName: 'seller_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      ref: true,
      fieldName: 'product_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
      index: 'fk_product_sellers_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';

export class Products {
  [PrimaryKeyProp]?: 'productId';
  productId!: number;
  name!: string;
  currentPrice!: string;
  currentQuantity: number & Opt = 0;
}

export const ProductsSchema = new EntitySchema({
  class: Products,
  properties: {
    productId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    currentPrice: { type: 'decimal', precision: 10, scale: 2 },
    currentQuantity: { type: 'integer' },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

export class Sales {
  [PrimaryKeyProp]?: 'saleId';
  saleId!: number;
  country!: Ref<ProductCountryMap>;
  seller!: Ref<ProductSellers>;
  singularPrice!: string;
  quantitySold: number & Opt = 1;
}

export const SalesSchema = new EntitySchema({
  class: Sales,
  indexes: [
    {
      name: 'product_id_idx',
      expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)',
    },
  ],
  properties: {
    saleId: { primary: true, type: 'integer' },
    country: {
      kind: 'm:1',
      entity: () => ProductCountryMap,
      ref: true,
      fieldNames: ['country', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_country_map1_idx',
    },
    seller: {
      kind: 'm:1',
      entity: () => ProductSellers,
      ref: true,
      fieldNames: ['seller_id', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_sellers1_idx',
    },
    singularPrice: { type: 'decimal', precision: 10, scale: 2 },
    quantitySold: { type: 'integer', unsigned: true },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

export class Sellers {
  [PrimaryKeyProp]?: 'sellerId';
  sellerId!: number;
  name!: string;
  productSellers = new Collection<Products>(this);
}

export const SellersSchema = new EntitySchema({
  class: Sellers,
  properties: {
    sellerId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    productSellers: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_sellers',
      pivotEntity: () => ProductSellers,
      joinColumn: 'seller_id',
      inverseJoinColumn: 'product_id',
    },
  },
});
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=smart > bidirectionalRelations=true > identifiedReferences=false > entitySchema=false > dump 1`] = `
[
  "import { Collection, Entity, ManyToMany, OneToMany, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

@Entity()
export class Countries {

  [PrimaryKeyProp]?: 'code';

  @PrimaryKey({ type: 'character', length: 2 })
  code!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_country_map', pivotEntity: () => ProductCountryMap, joinColumn: 'country', inverseJoinColumn: 'product_id' })
  productCountryMap = new Collection<Products>(this);

  @OneToMany({ entity: () => ProductCountryMap, mappedBy: 'country' })
  productCountryMapCollection = new Collection<ProductCountryMap>(this);

}
",
  "import { Collection, Entity, Index, ManyToOne, OneToMany, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';
import { Sales } from './Sales';

@Entity()
@Index({ name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] })
@Index({ name: 'primary_reindex_idx', properties: ['country', 'product'] })
export class ProductCountryMap {

  [PrimaryKeyProp]?: ['country', 'product'];

  @ManyToOne({ entity: () => Countries, fieldName: 'country', primary: true })
  country!: Countries;

  @ManyToOne({ entity: () => Products, fieldName: 'product_id', primary: true, index: 'fk_product_country_map_products1' })
  product!: Products;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

  @OneToMany({ entity: () => Sales, mappedBy: 'country' })
  salesCollection = new Collection<Sales>(this);

}
",
  "import { Collection, Entity, ManyToOne, OneToMany, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Products } from './Products';
import { Sales } from './Sales';
import { Sellers } from './Sellers';

@Entity()
export class ProductSellers {

  [PrimaryKeyProp]?: ['seller', 'product'];

  @ManyToOne({ entity: () => Sellers, fieldName: 'seller_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  seller!: Sellers;

  @ManyToOne({ entity: () => Products, fieldName: 'product_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true, index: 'fk_product_sellers_products1' })
  product!: Products;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

  @OneToMany({ entity: () => Sales, mappedBy: 'seller' })
  salesCollection = new Collection<Sales>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToMany, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';
import { Sellers } from './Sellers';

@Entity()
export class Products {

  [PrimaryKeyProp]?: 'productId';

  @PrimaryKey()
  productId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  currentPrice!: string;

  @Property({ type: 'integer' })
  currentQuantity: number & Opt = 0;

  @ManyToMany({ entity: () => Countries, mappedBy: 'productCountryMap' })
  productCountryMapInverse = new Collection<Countries>(this);

  @OneToMany({ entity: () => ProductCountryMap, mappedBy: 'product' })
  productCountryMapCollection = new Collection<ProductCountryMap>(this);

  @OneToMany({ entity: () => ProductSellers, mappedBy: 'product' })
  productSellersCollection = new Collection<ProductSellers>(this);

  @ManyToMany({ entity: () => Sellers, mappedBy: 'productSellers' })
  productSellersInverse = new Collection<Sellers>(this);

}
",
  "import { Entity, Index, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

@Entity()
@Index({ name: 'product_id_idx', expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)' })
export class Sales {

  [PrimaryKeyProp]?: 'saleId';

  @PrimaryKey()
  saleId!: number;

  @ManyToOne({ entity: () => ProductCountryMap, fieldNames: ['country', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_country_map1_idx' })
  country!: ProductCountryMap;

  @ManyToOne({ entity: () => ProductSellers, fieldNames: ['seller_id', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_sellers1_idx' })
  seller!: ProductSellers;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  singularPrice!: string;

  @Property({ type: 'integer', unsigned: true })
  quantitySold: number & Opt = 1;

}
",
  "import { Collection, Entity, ManyToMany, OneToMany, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

@Entity()
export class Sellers {

  [PrimaryKeyProp]?: 'sellerId';

  @PrimaryKey()
  sellerId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_sellers', pivotEntity: () => ProductSellers, joinColumn: 'seller_id', inverseJoinColumn: 'product_id' })
  productSellers = new Collection<Products>(this);

  @OneToMany({ entity: () => ProductSellers, mappedBy: 'seller' })
  productSellersCollection = new Collection<ProductSellers>(this);

}
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=smart > bidirectionalRelations=true > identifiedReferences=false > entitySchema=true > dump 1`] = `
[
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

export class Countries {
  [PrimaryKeyProp]?: 'code';
  code!: string;
  productCountryMap = new Collection<Products>(this);
  productCountryMapCollection = new Collection<ProductCountryMap>(this);
}

export const CountriesSchema = new EntitySchema({
  class: Countries,
  properties: {
    code: { primary: true, type: 'character', length: 2 },
    productCountryMap: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_country_map',
      pivotEntity: () => ProductCountryMap,
      joinColumn: 'country',
      inverseJoinColumn: 'product_id',
    },
    productCountryMapCollection: {
      kind: '1:m',
      entity: () => ProductCountryMap,
      mappedBy: 'country',
    },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';
import { Sales } from './Sales';

export class ProductCountryMap {
  [PrimaryKeyProp]?: ['country', 'product'];
  country!: Countries;
  product!: Products;
  isCurrentlyAllowed: boolean & Opt = false;
  salesCollection = new Collection<Sales>(this);
}

export const ProductCountryMapSchema = new EntitySchema({
  class: ProductCountryMap,
  indexes: [
    { name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] },
    { name: 'primary_reindex_idx', properties: ['country', 'product'] },
  ],
  properties: {
    country: {
      primary: true,
      kind: 'm:1',
      entity: () => Countries,
      fieldName: 'country',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      fieldName: 'product_id',
      index: 'fk_product_country_map_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
    salesCollection: { kind: '1:m', entity: () => Sales, mappedBy: 'country' },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Products } from './Products';
import { Sales } from './Sales';
import { Sellers } from './Sellers';

export class ProductSellers {
  [PrimaryKeyProp]?: ['seller', 'product'];
  seller!: Sellers;
  product!: Products;
  isCurrentlyAllowed: boolean & Opt = false;
  salesCollection = new Collection<Sales>(this);
}

export const ProductSellersSchema = new EntitySchema({
  class: ProductSellers,
  properties: {
    seller: {
      primary: true,
      kind: 'm:1',
      entity: () => Sellers,
      fieldName: 'seller_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      fieldName: 'product_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
      index: 'fk_product_sellers_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
    salesCollection: { kind: '1:m', entity: () => Sales, mappedBy: 'seller' },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';
import { Sellers } from './Sellers';

export class Products {
  [PrimaryKeyProp]?: 'productId';
  productId!: number;
  name!: string;
  currentPrice!: string;
  currentQuantity: number & Opt = 0;
  productCountryMapInverse = new Collection<Countries>(this);
  productCountryMapCollection = new Collection<ProductCountryMap>(this);
  productSellersCollection = new Collection<ProductSellers>(this);
  productSellersInverse = new Collection<Sellers>(this);
}

export const ProductsSchema = new EntitySchema({
  class: Products,
  properties: {
    productId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    currentPrice: { type: 'decimal', precision: 10, scale: 2 },
    currentQuantity: { type: 'integer' },
    productCountryMapInverse: {
      kind: 'm:n',
      entity: () => Countries,
      mappedBy: 'productCountryMap',
    },
    productCountryMapCollection: {
      kind: '1:m',
      entity: () => ProductCountryMap,
      mappedBy: 'product',
    },
    productSellersCollection: {
      kind: '1:m',
      entity: () => ProductSellers,
      mappedBy: 'product',
    },
    productSellersInverse: {
      kind: 'm:n',
      entity: () => Sellers,
      mappedBy: 'productSellers',
    },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

export class Sales {
  [PrimaryKeyProp]?: 'saleId';
  saleId!: number;
  country!: ProductCountryMap;
  seller!: ProductSellers;
  singularPrice!: string;
  quantitySold: number & Opt = 1;
}

export const SalesSchema = new EntitySchema({
  class: Sales,
  indexes: [
    {
      name: 'product_id_idx',
      expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)',
    },
  ],
  properties: {
    saleId: { primary: true, type: 'integer' },
    country: {
      kind: 'm:1',
      entity: () => ProductCountryMap,
      fieldNames: ['country', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_country_map1_idx',
    },
    seller: {
      kind: 'm:1',
      entity: () => ProductSellers,
      fieldNames: ['seller_id', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_sellers1_idx',
    },
    singularPrice: { type: 'decimal', precision: 10, scale: 2 },
    quantitySold: { type: 'integer', unsigned: true },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

export class Sellers {
  [PrimaryKeyProp]?: 'sellerId';
  sellerId!: number;
  name!: string;
  productSellers = new Collection<Products>(this);
  productSellersCollection = new Collection<ProductSellers>(this);
}

export const SellersSchema = new EntitySchema({
  class: Sellers,
  properties: {
    sellerId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    productSellers: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_sellers',
      pivotEntity: () => ProductSellers,
      joinColumn: 'seller_id',
      inverseJoinColumn: 'product_id',
    },
    productSellersCollection: {
      kind: '1:m',
      entity: () => ProductSellers,
      mappedBy: 'seller',
    },
  },
});
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=smart > bidirectionalRelations=true > identifiedReferences=true > entitySchema=false > dump 1`] = `
[
  "import { Collection, Entity, ManyToMany, OneToMany, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

@Entity()
export class Countries {

  [PrimaryKeyProp]?: 'code';

  @PrimaryKey({ type: 'character', length: 2 })
  code!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_country_map', pivotEntity: () => ProductCountryMap, joinColumn: 'country', inverseJoinColumn: 'product_id' })
  productCountryMap = new Collection<Products>(this);

  @OneToMany({ entity: () => ProductCountryMap, mappedBy: 'country' })
  productCountryMapCollection = new Collection<ProductCountryMap>(this);

}
",
  "import { Collection, Entity, Index, ManyToOne, OneToMany, type Opt, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';
import { Sales } from './Sales';

@Entity()
@Index({ name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] })
@Index({ name: 'primary_reindex_idx', properties: ['country', 'product'] })
export class ProductCountryMap {

  [PrimaryKeyProp]?: ['country', 'product'];

  @ManyToOne({ entity: () => Countries, ref: true, fieldName: 'country', primary: true })
  country!: Ref<Countries>;

  @ManyToOne({ entity: () => Products, ref: true, fieldName: 'product_id', primary: true, index: 'fk_product_country_map_products1' })
  product!: Ref<Products>;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

  @OneToMany({ entity: () => Sales, mappedBy: 'country' })
  salesCollection = new Collection<Sales>(this);

}
",
  "import { Collection, Entity, ManyToOne, OneToMany, type Opt, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { Products } from './Products';
import { Sales } from './Sales';
import { Sellers } from './Sellers';

@Entity()
export class ProductSellers {

  [PrimaryKeyProp]?: ['seller', 'product'];

  @ManyToOne({ entity: () => Sellers, ref: true, fieldName: 'seller_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  seller!: Ref<Sellers>;

  @ManyToOne({ entity: () => Products, ref: true, fieldName: 'product_id', updateRule: 'cascade', deleteRule: 'cascade', primary: true, index: 'fk_product_sellers_products1' })
  product!: Ref<Products>;

  @Property({ type: 'boolean' })
  isCurrentlyAllowed: boolean & Opt = false;

  @OneToMany({ entity: () => Sales, mappedBy: 'seller' })
  salesCollection = new Collection<Sales>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToMany, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';
import { Sellers } from './Sellers';

@Entity()
export class Products {

  [PrimaryKeyProp]?: 'productId';

  @PrimaryKey()
  productId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  currentPrice!: string;

  @Property({ type: 'integer' })
  currentQuantity: number & Opt = 0;

  @ManyToMany({ entity: () => Countries, mappedBy: 'productCountryMap' })
  productCountryMapInverse = new Collection<Countries>(this);

  @OneToMany({ entity: () => ProductCountryMap, mappedBy: 'product' })
  productCountryMapCollection = new Collection<ProductCountryMap>(this);

  @OneToMany({ entity: () => ProductSellers, mappedBy: 'product' })
  productSellersCollection = new Collection<ProductSellers>(this);

  @ManyToMany({ entity: () => Sellers, mappedBy: 'productSellers' })
  productSellersInverse = new Collection<Sellers>(this);

}
",
  "import { Entity, Index, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property, type Ref } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

@Entity()
@Index({ name: 'product_id_idx', expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)' })
export class Sales {

  [PrimaryKeyProp]?: 'saleId';

  @PrimaryKey()
  saleId!: number;

  @ManyToOne({ entity: () => ProductCountryMap, ref: true, fieldNames: ['country', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_country_map1_idx' })
  country!: Ref<ProductCountryMap>;

  @ManyToOne({ entity: () => ProductSellers, ref: true, fieldNames: ['seller_id', 'product_id'], updateRule: 'cascade', index: 'fk_sales_product_sellers1_idx' })
  seller!: Ref<ProductSellers>;

  @Property({ type: 'decimal', precision: 10, scale: 2 })
  singularPrice!: string;

  @Property({ type: 'integer', unsigned: true })
  quantitySold: number & Opt = 1;

}
",
  "import { Collection, Entity, ManyToMany, OneToMany, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

@Entity()
export class Sellers {

  [PrimaryKeyProp]?: 'sellerId';

  @PrimaryKey()
  sellerId!: number;

  @Property({ unique: 'name_UNIQUE' })
  name!: string;

  @ManyToMany({ entity: () => Products, pivotTable: 'product_sellers', pivotEntity: () => ProductSellers, joinColumn: 'seller_id', inverseJoinColumn: 'product_id' })
  productSellers = new Collection<Products>(this);

  @OneToMany({ entity: () => ProductSellers, mappedBy: 'seller' })
  productSellersCollection = new Collection<ProductSellers>(this);

}
",
]
`;

exports[`overlap_fk_example > scalarPropertiesForRelations=smart > bidirectionalRelations=true > identifiedReferences=true > entitySchema=true > dump 1`] = `
[
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { Products } from './Products';

export class Countries {
  [PrimaryKeyProp]?: 'code';
  code!: string;
  productCountryMap = new Collection<Products>(this);
  productCountryMapCollection = new Collection<ProductCountryMap>(this);
}

export const CountriesSchema = new EntitySchema({
  class: Countries,
  properties: {
    code: { primary: true, type: 'character', length: 2 },
    productCountryMap: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_country_map',
      pivotEntity: () => ProductCountryMap,
      joinColumn: 'country',
      inverseJoinColumn: 'product_id',
    },
    productCountryMapCollection: {
      kind: '1:m',
      entity: () => ProductCountryMap,
      mappedBy: 'country',
    },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { Countries } from './Countries';
import { Products } from './Products';
import { Sales } from './Sales';

export class ProductCountryMap {
  [PrimaryKeyProp]?: ['country', 'product'];
  country!: Ref<Countries>;
  product!: Ref<Products>;
  isCurrentlyAllowed: boolean & Opt = false;
  salesCollection = new Collection<Sales>(this);
}

export const ProductCountryMapSchema = new EntitySchema({
  class: ProductCountryMap,
  indexes: [
    { name: 'full_idx', properties: ['country', 'product', 'isCurrentlyAllowed'] },
    { name: 'primary_reindex_idx', properties: ['country', 'product'] },
  ],
  properties: {
    country: {
      primary: true,
      kind: 'm:1',
      entity: () => Countries,
      ref: true,
      fieldName: 'country',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      ref: true,
      fieldName: 'product_id',
      index: 'fk_product_country_map_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
    salesCollection: { kind: '1:m', entity: () => Sales, mappedBy: 'country' },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { Products } from './Products';
import { Sales } from './Sales';
import { Sellers } from './Sellers';

export class ProductSellers {
  [PrimaryKeyProp]?: ['seller', 'product'];
  seller!: Ref<Sellers>;
  product!: Ref<Products>;
  isCurrentlyAllowed: boolean & Opt = false;
  salesCollection = new Collection<Sales>(this);
}

export const ProductSellersSchema = new EntitySchema({
  class: ProductSellers,
  properties: {
    seller: {
      primary: true,
      kind: 'm:1',
      entity: () => Sellers,
      ref: true,
      fieldName: 'seller_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    product: {
      primary: true,
      kind: 'm:1',
      entity: () => Products,
      ref: true,
      fieldName: 'product_id',
      updateRule: 'cascade',
      deleteRule: 'cascade',
      index: 'fk_product_sellers_products1',
    },
    isCurrentlyAllowed: { type: 'boolean' },
    salesCollection: { kind: '1:m', entity: () => Sales, mappedBy: 'seller' },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Countries } from './Countries';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';
import { Sellers } from './Sellers';

export class Products {
  [PrimaryKeyProp]?: 'productId';
  productId!: number;
  name!: string;
  currentPrice!: string;
  currentQuantity: number & Opt = 0;
  productCountryMapInverse = new Collection<Countries>(this);
  productCountryMapCollection = new Collection<ProductCountryMap>(this);
  productSellersCollection = new Collection<ProductSellers>(this);
  productSellersInverse = new Collection<Sellers>(this);
}

export const ProductsSchema = new EntitySchema({
  class: Products,
  properties: {
    productId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    currentPrice: { type: 'decimal', precision: 10, scale: 2 },
    currentQuantity: { type: 'integer' },
    productCountryMapInverse: {
      kind: 'm:n',
      entity: () => Countries,
      mappedBy: 'productCountryMap',
    },
    productCountryMapCollection: {
      kind: '1:m',
      entity: () => ProductCountryMap,
      mappedBy: 'product',
    },
    productSellersCollection: {
      kind: '1:m',
      entity: () => ProductSellers,
      mappedBy: 'product',
    },
    productSellersInverse: {
      kind: 'm:n',
      entity: () => Sellers,
      mappedBy: 'productSellers',
    },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp, type Ref } from '@mikro-orm/core';
import { ProductCountryMap } from './ProductCountryMap';
import { ProductSellers } from './ProductSellers';

export class Sales {
  [PrimaryKeyProp]?: 'saleId';
  saleId!: number;
  country!: Ref<ProductCountryMap>;
  seller!: Ref<ProductSellers>;
  singularPrice!: string;
  quantitySold: number & Opt = 1;
}

export const SalesSchema = new EntitySchema({
  class: Sales,
  indexes: [
    {
      name: 'product_id_idx',
      expression: 'alter table \`sales\` add index \`product_id_idx\` (\`product_id\`)',
    },
  ],
  properties: {
    saleId: { primary: true, type: 'integer' },
    country: {
      kind: 'm:1',
      entity: () => ProductCountryMap,
      ref: true,
      fieldNames: ['country', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_country_map1_idx',
    },
    seller: {
      kind: 'm:1',
      entity: () => ProductSellers,
      ref: true,
      fieldNames: ['seller_id', 'product_id'],
      updateRule: 'cascade',
      index: 'fk_sales_product_sellers1_idx',
    },
    singularPrice: { type: 'decimal', precision: 10, scale: 2 },
    quantitySold: { type: 'integer', unsigned: true },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { ProductSellers } from './ProductSellers';
import { Products } from './Products';

export class Sellers {
  [PrimaryKeyProp]?: 'sellerId';
  sellerId!: number;
  name!: string;
  productSellers = new Collection<Products>(this);
  productSellersCollection = new Collection<ProductSellers>(this);
}

export const SellersSchema = new EntitySchema({
  class: Sellers,
  properties: {
    sellerId: { primary: true, type: 'integer' },
    name: { type: 'string', unique: 'name_UNIQUE' },
    productSellers: {
      kind: 'm:n',
      entity: () => Products,
      pivotTable: 'product_sellers',
      pivotEntity: () => ProductSellers,
      joinColumn: 'seller_id',
      inverseJoinColumn: 'product_id',
    },
    productSellersCollection: {
      kind: '1:m',
      entity: () => ProductSellers,
      mappedBy: 'seller',
    },
  },
});
",
]
`;
