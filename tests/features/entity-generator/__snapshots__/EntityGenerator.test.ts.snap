// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`EntityGenerator > generate entities from schema [sqlite] > sqlite-entity-dump 1`] = `
[
  "import { Collection, type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Book4 } from './book4';

export class Author4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Ref<Book4>;
  identity?: any;
  book4Collection = new Collection<Book4>(this);
}

export const Author4Schema = defineEntity({
  class: Author4,
  properties: {
    id: p.integer().primary(),
    createdAt: p.datetime().nullable(),
    updatedAt: p.datetime().nullable(),
    name: p.text(),
    email: p.text().unique('author4_email_unique'),
    age: p.integer().nullable(),
    termsAccepted: p.integer(),
    identities: p.text().nullable(),
    born: p.date().nullable(),
    bornTime: p.time().nullable(),
    favouriteBook: () => p.manyToOne(Book4).ref().updateRule('no action').nullable(),
    identity: p.json().nullable(),
    book4Collection: () => p.oneToMany(Book4).mappedBy('author'),
  },
});
",
  "import { Collection, type Opt, defineEntity, p } from '@mikro-orm/core';
import { Book4 } from './book4';
import { TagsOrdered } from './tags-ordered';

export class BookTag4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
  tagsUnorderedInverse = new Collection<Book4>(this);
  tagsOrderedCollection = new Collection<TagsOrdered>(this);
}

export const BookTag4Schema = defineEntity({
  class: BookTag4,
  properties: {
    id: p.integer().primary(),
    createdAt: p.datetime().nullable(),
    updatedAt: p.datetime().nullable(),
    name: p.text(),
    version: p.datetime().defaultRaw(\`current_timestamp\`),
    tagsUnorderedInverse: () => p.manyToMany(Book4).mappedBy('tagsUnordered'),
    tagsOrderedCollection: () => p.oneToMany(TagsOrdered).mappedBy('bookTag4'),
  },
});
",
  "import { Collection, type Ref, defineEntity, p } from '@mikro-orm/core';
import { Author4 } from './author4';
import { BookTag4 } from './book-tag4';
import { Publisher4 } from './publisher4';
import { TagsOrdered } from './tags-ordered';

export class Book4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Ref<Author4>;
  publisher?: Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
  author4Collection = new Collection<Author4>(this);
  tagsOrderedCollection = new Collection<TagsOrdered>(this);
}

export const Book4Schema = defineEntity({
  class: Book4,
  properties: {
    id: p.integer().primary(),
    createdAt: p.datetime().nullable(),
    updatedAt: p.datetime().nullable(),
    title: p.text(),
    price: p.unknown().columnType('REAL').nullable(),
    author: () => p.manyToOne(Author4).ref().updateRule('no action').nullable(),
    publisher: () => p.manyToOne(Publisher4).ref().updateRule('no action').nullable(),
    meta: p.json().nullable(),
    tagsUnordered: () => p.manyToMany(BookTag4).pivotTable('tags_unordered').joinColumn('book4_id').inverseJoinColumn('book_tag4_id'),
    author4Collection: () => p.oneToMany(Author4).mappedBy('favouriteBook'),
    tagsOrderedCollection: () => p.oneToMany(TagsOrdered).mappedBy('book4'),
  },
});
",
  "import { type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { FooBaz4 } from './foo-baz4';

export class FooBar4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: Ref<FooBaz4>;
  fooBar?: Ref<FooBar4>;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: Ref<FooBar4>;
}

export const FooBar4Schema = defineEntity({
  class: FooBar4,
  properties: {
    id: p.integer().primary(),
    createdAt: p.datetime().nullable(),
    updatedAt: p.datetime().nullable(),
    name: p.text(),
    baz: () => p.oneToOne(FooBaz4).ref().updateRule('no action').nullable(),
    fooBar: () => p.oneToOne(FooBar4).ref().updateRule('no action').nullable(),
    version: p.integer(),
    blob: p.blob().nullable(),
    blob2: p.blob().nullable(),
    array: p.text().nullable(),
    object: p.json().nullable(),
    fooBar4: () => p.oneToOne(FooBar4).ref().mappedBy('fooBar'),
  },
});
",
  "import { type Opt, type Ref, defineEntity, p } from '@mikro-orm/core';
import { FooBar4 } from './foo-bar4';

export class FooBaz4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
  fooBar4?: Ref<FooBar4>;
}

export const FooBaz4Schema = defineEntity({
  class: FooBaz4,
  properties: {
    id: p.integer().primary(),
    createdAt: p.datetime().nullable(),
    updatedAt: p.datetime().nullable(),
    name: p.text(),
    version: p.datetime().defaultRaw(\`current_timestamp\`),
    fooBar4: () => p.oneToOne(FooBar4).ref().mappedBy('baz'),
  },
});
",
  "import { Collection, type Opt, defineEntity, p } from '@mikro-orm/core';
import { Book4 } from './book4';
import { Publisher4Tests } from './publisher4tests';

export class Publisher4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: TPublisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new Collection<Book4>(this);
  publisher4TestsCollection = new Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = defineEntity({
  class: Publisher4,
  properties: {
    id: p.integer().primary(),
    createdAt: p.datetime().nullable(),
    updatedAt: p.datetime().nullable(),
    name: p.text(),
    type: p.enum(() => Publisher4Type),
    enum3: p.integer().nullable(),
    book4Collection: () => p.oneToMany(Book4).mappedBy('publisher'),
    publisher4TestsCollection: () => p.oneToMany(Publisher4Tests).mappedBy('publisher4'),
  },
});
",
  "import { type Ref, defineEntity, p } from '@mikro-orm/core';
import { Publisher4 } from './publisher4';
import { Test4 } from './test4';

export class Publisher4Tests {
  id!: number;
  publisher4!: Ref<Publisher4>;
  test4!: Ref<Test4>;
}

export const Publisher4TestsSchema = defineEntity({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: p.integer().primary(),
    publisher4: () => p.manyToOne(Publisher4).ref(),
    test4: () => p.manyToOne(Test4).ref(),
  },
});
",
  "import { type Ref, defineEntity, p } from '@mikro-orm/core';
import { BookTag4 } from './book-tag4';
import { Book4 } from './book4';

export class TagsOrdered {
  id!: number;
  book4!: Ref<Book4>;
  bookTag4!: Ref<BookTag4>;
}

export const TagsOrderedSchema = defineEntity({
  class: TagsOrdered,
  properties: {
    id: p.integer().primary(),
    book4: () => p.manyToOne(Book4).ref(),
    bookTag4: () => p.manyToOne(BookTag4).ref(),
  },
});
",
  "import { Collection, type Opt, defineEntity, p } from '@mikro-orm/core';
import { Publisher4Tests } from './publisher4tests';

export class Test4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
  publisher4TestsCollection = new Collection<Publisher4Tests>(this);
}

export const Test4Schema = defineEntity({
  class: Test4,
  properties: {
    id: p.integer().primary(),
    createdAt: p.datetime().nullable(),
    updatedAt: p.datetime().nullable(),
    name: p.text().nullable(),
    version: p.integer(),
    publisher4TestsCollection: () => p.oneToMany(Publisher4Tests).mappedBy('test4'),
  },
});
",
]
`;
