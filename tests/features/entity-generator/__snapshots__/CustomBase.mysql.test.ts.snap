// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName= entitySchema=false: dump 1`] = `
[
  "import { Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';

@Entity()
export class Address2 {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book2 } from './Book2';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';

@Entity()
export class BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class BookTag2 {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';

@Entity()
export class CarOwner2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';

@Entity()
export class Car2 {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Entity, PrimaryKey } from '@mikro-orm/core';

@Entity()
export class Dummy2 {

  @PrimaryKey()
  id!: number;

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class FooBaz2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Publisher2 {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Sandwich {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName= entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';

export class Address2 {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';

export class Author2 {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';

export class BaseUser2 {
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';

export class BookTag2 {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

export class Book2 {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Car2 } from './Car2';

export class CarOwner2 {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';

export class Car2 {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Test2 } from './Test2';

export class Configuration2 {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';

export class Dummy2 {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';

export class FooBaz2 {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';

export class Publisher2 {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';

export class Sandwich {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

export class Test2 {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

export class User2 {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName=BaseEntity entitySchema=false: dump 1`] = `
[
  "import { Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Address2 extends BaseEntity {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class BaseUser2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class BookTag2 extends BaseEntity {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 extends BaseEntity {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags extends BaseEntity {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';

@Entity()
export class CarOwner2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Car2 extends BaseEntity {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 extends BaseEntity {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Entity, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Dummy2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class FooBaz2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 extends BaseEntity {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Publisher2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Sandwich extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 extends BaseEntity {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
  "import { Config, type DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity {

  [Config]?: DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName=BaseEntity entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';

export class Address2 extends BaseEntity {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';

export class Author2 extends BaseEntity {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BaseUser2 extends BaseEntity {
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BookTag2 extends BaseEntity {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

export class Book2 extends BaseEntity {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags extends BaseEntity {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';

export class CarOwner2 extends BaseEntity {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Car2 extends BaseEntity {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Test2 } from './Test2';

export class Configuration2 extends BaseEntity {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Dummy2 extends BaseEntity {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 extends BaseEntity {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class FooBaz2 extends BaseEntity {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 extends BaseEntity {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Publisher2 extends BaseEntity {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests extends BaseEntity {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Sandwich extends BaseEntity {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

export class Test2 extends BaseEntity {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

export class User2 extends BaseEntity {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
  "import { Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity {
  [Config]?: DefineConfig<{ forceObject: false }>;
}

export const BaseEntitySchema = new EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName=BaseUser2 entitySchema=false: dump 1`] = `
[
  "import { Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Address2 extends BaseUser2 {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { Config, type DefineConfig, Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';

@Entity()
export class BaseUser2 {

  [Config]?: DefineConfig<{ forceObject: false }>;


  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class BookTag2 extends BaseUser2 {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 extends BaseUser2 {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags extends BaseUser2 {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';

@Entity()
export class CarOwner2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Car2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Entity, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Dummy2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class FooBaz2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Publisher2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Sandwich extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName=BaseUser2 entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';

export class Address2 extends BaseUser2 {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';

export class Author2 extends BaseUser2 {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export class BaseUser2 {
  [Config]?: DefineConfig<{ forceObject: false }>;
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class BookTag2 extends BaseUser2 {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

export class Book2 extends BaseUser2 {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags extends BaseUser2 {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';

export class CarOwner2 extends BaseUser2 {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Car2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Test2 } from './Test2';

export class Configuration2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Dummy2 extends BaseUser2 {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 extends BaseUser2 {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class FooBaz2 extends BaseUser2 {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Publisher2 extends BaseUser2 {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests extends BaseUser2 {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Sandwich extends BaseUser2 {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

export class Test2 extends BaseUser2 {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

export class User2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName=CustomBase entitySchema=false: dump 1`] = `
[
  "import { Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { CustomBase } from './CustomBase';

@Entity()
export class Address2 extends CustomBase {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class BaseUser2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class BookTag2 extends CustomBase {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 extends CustomBase {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags extends CustomBase {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';

@Entity()
export class CarOwner2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Car2 extends CustomBase {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 extends CustomBase {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Entity, PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Dummy2 extends CustomBase {

  @PrimaryKey()
  id!: number;

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class FooBaz2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 extends CustomBase {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Publisher2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests extends CustomBase {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Sandwich extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 extends CustomBase {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
  "import { Config, type DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase {

  [Config]?: DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName=CustomBase entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { CustomBase } from './CustomBase';

export class Address2 extends CustomBase {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';

export class Author2 extends CustomBase {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BaseUser2 extends CustomBase {
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BookTag2 extends CustomBase {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';

export class Book2 extends CustomBase {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';

export class Book2Tags extends CustomBase {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';

export class CarOwner2 extends CustomBase {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Car2 extends CustomBase {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Test2 } from './Test2';

export class Configuration2 extends CustomBase {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Dummy2 extends CustomBase {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 extends CustomBase {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class FooBaz2 extends CustomBase {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 extends CustomBase {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Publisher2 extends CustomBase {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests extends CustomBase {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Sandwich extends CustomBase {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';

export class Test2 extends CustomBase {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';
import { Sandwich } from './Sandwich';

export class User2 extends CustomBase {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
  "import { Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase {
  [Config]?: DefineConfig<{ forceObject: false }>;
}

export const CustomBaseSchema = new EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName= entitySchema=false: dump 1`] = `
[
  "import { BaseEntity, Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';

@Entity()
export class Address2 extends BaseEntity {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { BaseEntity, Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book2 } from './Book2';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { BaseEntity, Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';

@Entity()
export class BaseUser2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { BaseEntity, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class BookTag2 extends BaseEntity {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { BaseEntity, Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 extends BaseEntity {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { BaseEntity, Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags extends BaseEntity {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { BaseEntity, Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';

@Entity()
export class CarOwner2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { BaseEntity, Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';

@Entity()
export class Car2 extends BaseEntity {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { BaseEntity, Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 extends BaseEntity {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { BaseEntity, Entity, PrimaryKey } from '@mikro-orm/core';

@Entity()
export class Dummy2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

}
",
  "import { BaseEntity, Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { BaseEntity, Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class FooBaz2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { BaseEntity, Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 extends BaseEntity {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { BaseEntity, Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Publisher2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { BaseEntity, Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { BaseEntity, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Sandwich extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { BaseEntity, Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { BaseEntity, Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 extends BaseEntity {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName= entitySchema=true: dump 1`] = `
[
  "import { BaseEntity, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';

export class Address2 extends BaseEntity {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { BaseEntity, Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';

export class Author2 extends BaseEntity {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';

export class BaseUser2 extends BaseEntity {
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';

export class BookTag2 extends BaseEntity {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { BaseEntity, Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

export class Book2 extends BaseEntity {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { BaseEntity, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags extends BaseEntity {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';
import { Car2 } from './Car2';

export class CarOwner2 extends BaseEntity {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { BaseEntity, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';

export class Car2 extends BaseEntity {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { BaseEntity, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Test2 } from './Test2';

export class Configuration2 extends BaseEntity {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';

export class Dummy2 extends BaseEntity {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 extends BaseEntity {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';

export class FooBaz2 extends BaseEntity {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 extends BaseEntity {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';

export class Publisher2 extends BaseEntity {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests extends BaseEntity {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';

export class Sandwich extends BaseEntity {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { BaseEntity, Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

export class Test2 extends BaseEntity {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { BaseEntity, Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

export class User2 extends BaseEntity {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName=BaseEntity entitySchema=false: dump 1`] = `
[
  "import { Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Address2 extends BaseEntity {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class BaseUser2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class BookTag2 extends BaseEntity {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 extends BaseEntity {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags extends BaseEntity {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';

@Entity()
export class CarOwner2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Car2 extends BaseEntity {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 extends BaseEntity {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Entity, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Dummy2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class FooBaz2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 extends BaseEntity {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Publisher2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Sandwich extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 extends BaseEntity {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
  "import { BaseEntity as MikroBaseEntity, Config, type DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroBaseEntity {

  [Config]?: DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName=BaseEntity entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';

export class Address2 extends BaseEntity {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';

export class Author2 extends BaseEntity {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BaseUser2 extends BaseEntity {
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BookTag2 extends BaseEntity {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

export class Book2 extends BaseEntity {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags extends BaseEntity {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';

export class CarOwner2 extends BaseEntity {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Car2 extends BaseEntity {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Test2 } from './Test2';

export class Configuration2 extends BaseEntity {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Dummy2 extends BaseEntity {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 extends BaseEntity {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class FooBaz2 extends BaseEntity {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 extends BaseEntity {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Publisher2 extends BaseEntity {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests extends BaseEntity {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Sandwich extends BaseEntity {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

export class Test2 extends BaseEntity {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

export class User2 extends BaseEntity {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
  "import { BaseEntity as MikroBaseEntity, Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroBaseEntity {
  [Config]?: DefineConfig<{ forceObject: false }>;
}

export const BaseEntitySchema = new EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName=BaseUser2 entitySchema=false: dump 1`] = `
[
  "import { Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Address2 extends BaseUser2 {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { BaseEntity, Config, type DefineConfig, Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';

@Entity()
export class BaseUser2 extends BaseEntity {

  [Config]?: DefineConfig<{ forceObject: false }>;


  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class BookTag2 extends BaseUser2 {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 extends BaseUser2 {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags extends BaseUser2 {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';

@Entity()
export class CarOwner2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Car2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Entity, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Dummy2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class FooBaz2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Publisher2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Sandwich extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName=BaseUser2 entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';

export class Address2 extends BaseUser2 {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';

export class Author2 extends BaseUser2 {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { BaseEntity, Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export class BaseUser2 extends BaseEntity {
  [Config]?: DefineConfig<{ forceObject: false }>;
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class BookTag2 extends BaseUser2 {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

export class Book2 extends BaseUser2 {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags extends BaseUser2 {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';

export class CarOwner2 extends BaseUser2 {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Car2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Test2 } from './Test2';

export class Configuration2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Dummy2 extends BaseUser2 {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 extends BaseUser2 {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class FooBaz2 extends BaseUser2 {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Publisher2 extends BaseUser2 {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests extends BaseUser2 {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Sandwich extends BaseUser2 {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

export class Test2 extends BaseUser2 {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

export class User2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName=CustomBase entitySchema=false: dump 1`] = `
[
  "import { Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { CustomBase } from './CustomBase';

@Entity()
export class Address2 extends CustomBase {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class BaseUser2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class BookTag2 extends CustomBase {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 extends CustomBase {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags extends CustomBase {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';

@Entity()
export class CarOwner2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Car2 extends CustomBase {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 extends CustomBase {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Entity, PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Dummy2 extends CustomBase {

  @PrimaryKey()
  id!: number;

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class FooBaz2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 extends CustomBase {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Publisher2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests extends CustomBase {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Sandwich extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 extends CustomBase {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
  "import { BaseEntity, Config, type DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase extends BaseEntity {

  [Config]?: DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName=CustomBase entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { CustomBase } from './CustomBase';

export class Address2 extends CustomBase {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';

export class Author2 extends CustomBase {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BaseUser2 extends CustomBase {
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BookTag2 extends CustomBase {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';

export class Book2 extends CustomBase {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';

export class Book2Tags extends CustomBase {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';

export class CarOwner2 extends CustomBase {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Car2 extends CustomBase {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Test2 } from './Test2';

export class Configuration2 extends CustomBase {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Dummy2 extends CustomBase {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 extends CustomBase {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class FooBaz2 extends CustomBase {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 extends CustomBase {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Publisher2 extends CustomBase {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests extends CustomBase {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Sandwich extends CustomBase {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';

export class Test2 extends CustomBase {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';
import { Sandwich } from './Sandwich';

export class User2 extends CustomBase {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
  "import { BaseEntity, Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase extends BaseEntity {
  [Config]?: DefineConfig<{ forceObject: false }>;
}

export const CustomBaseSchema = new EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName= entitySchema=false: dump 1`] = `
[
  "import { Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';

@Entity()
export class Address2 {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book2 } from './Book2';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';

@Entity()
export class BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class BookTag2 {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';

@Entity()
export class CarOwner2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';

@Entity()
export class Car2 {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Entity, PrimaryKey } from '@mikro-orm/core';

@Entity()
export class Dummy2 {

  @PrimaryKey()
  id!: number;

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class FooBaz2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Publisher2 {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Sandwich {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName= entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';

export class Address2 {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';

export class Author2 {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';

export class BaseUser2 {
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';

export class BookTag2 {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

export class Book2 {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Car2 } from './Car2';

export class CarOwner2 {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';

export class Car2 {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Test2 } from './Test2';

export class Configuration2 {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';

export class Dummy2 {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';

export class FooBaz2 {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';

export class Publisher2 {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';

export class Sandwich {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

export class Test2 {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

export class User2 {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName=BaseEntity entitySchema=false: dump 1`] = `
[
  "import { Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Address2 extends BaseEntity {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class BaseUser2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class BookTag2 extends BaseEntity {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 extends BaseEntity {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags extends BaseEntity {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';

@Entity()
export class CarOwner2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Car2 extends BaseEntity {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 extends BaseEntity {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Entity, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Dummy2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class FooBaz2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 extends BaseEntity {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Publisher2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Sandwich extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 extends BaseEntity {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
  "import { Config, type DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity {

  [Config]?: DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName=BaseEntity entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';

export class Address2 extends BaseEntity {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';

export class Author2 extends BaseEntity {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BaseUser2 extends BaseEntity {
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BookTag2 extends BaseEntity {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

export class Book2 extends BaseEntity {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags extends BaseEntity {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';

export class CarOwner2 extends BaseEntity {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Car2 extends BaseEntity {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Test2 } from './Test2';

export class Configuration2 extends BaseEntity {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Dummy2 extends BaseEntity {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 extends BaseEntity {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class FooBaz2 extends BaseEntity {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 extends BaseEntity {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Publisher2 extends BaseEntity {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests extends BaseEntity {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Sandwich extends BaseEntity {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

export class Test2 extends BaseEntity {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

export class User2 extends BaseEntity {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
  "import { Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity {
  [Config]?: DefineConfig<{ forceObject: true }>;
}

export const BaseEntitySchema = new EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName=BaseUser2 entitySchema=false: dump 1`] = `
[
  "import { Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Address2 extends BaseUser2 {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { Config, type DefineConfig, Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';

@Entity()
export class BaseUser2 {

  [Config]?: DefineConfig<{ forceObject: true }>;


  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class BookTag2 extends BaseUser2 {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 extends BaseUser2 {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags extends BaseUser2 {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';

@Entity()
export class CarOwner2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Car2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Entity, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Dummy2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class FooBaz2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Publisher2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Sandwich extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName=BaseUser2 entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';

export class Address2 extends BaseUser2 {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';

export class Author2 extends BaseUser2 {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export class BaseUser2 {
  [Config]?: DefineConfig<{ forceObject: true }>;
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class BookTag2 extends BaseUser2 {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

export class Book2 extends BaseUser2 {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags extends BaseUser2 {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';

export class CarOwner2 extends BaseUser2 {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Car2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Test2 } from './Test2';

export class Configuration2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Dummy2 extends BaseUser2 {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 extends BaseUser2 {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class FooBaz2 extends BaseUser2 {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Publisher2 extends BaseUser2 {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests extends BaseUser2 {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Sandwich extends BaseUser2 {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

export class Test2 extends BaseUser2 {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

export class User2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName=CustomBase entitySchema=false: dump 1`] = `
[
  "import { Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { CustomBase } from './CustomBase';

@Entity()
export class Address2 extends CustomBase {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class BaseUser2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class BookTag2 extends CustomBase {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 extends CustomBase {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags extends CustomBase {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';

@Entity()
export class CarOwner2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Car2 extends CustomBase {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 extends CustomBase {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Entity, PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Dummy2 extends CustomBase {

  @PrimaryKey()
  id!: number;

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class FooBaz2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 extends CustomBase {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Publisher2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests extends CustomBase {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Sandwich extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 extends CustomBase {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
  "import { Config, type DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase {

  [Config]?: DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName=CustomBase entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { CustomBase } from './CustomBase';

export class Address2 extends CustomBase {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';

export class Author2 extends CustomBase {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BaseUser2 extends CustomBase {
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BookTag2 extends CustomBase {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';

export class Book2 extends CustomBase {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';

export class Book2Tags extends CustomBase {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';

export class CarOwner2 extends CustomBase {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Car2 extends CustomBase {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Test2 } from './Test2';

export class Configuration2 extends CustomBase {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Dummy2 extends CustomBase {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 extends CustomBase {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class FooBaz2 extends CustomBase {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 extends CustomBase {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Publisher2 extends CustomBase {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests extends CustomBase {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Sandwich extends CustomBase {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';

export class Test2 extends CustomBase {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';
import { Sandwich } from './Sandwich';

export class User2 extends CustomBase {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
  "import { Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase {
  [Config]?: DefineConfig<{ forceObject: true }>;
}

export const CustomBaseSchema = new EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName= entitySchema=false: dump 1`] = `
[
  "import { BaseEntity, Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';

@Entity()
export class Address2 extends BaseEntity {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { BaseEntity, Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book2 } from './Book2';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { BaseEntity, Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';

@Entity()
export class BaseUser2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { BaseEntity, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class BookTag2 extends BaseEntity {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { BaseEntity, Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 extends BaseEntity {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { BaseEntity, Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags extends BaseEntity {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { BaseEntity, Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';

@Entity()
export class CarOwner2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { BaseEntity, Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';

@Entity()
export class Car2 extends BaseEntity {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { BaseEntity, Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 extends BaseEntity {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { BaseEntity, Entity, PrimaryKey } from '@mikro-orm/core';

@Entity()
export class Dummy2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

}
",
  "import { BaseEntity, Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { BaseEntity, Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class FooBaz2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { BaseEntity, Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 extends BaseEntity {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { BaseEntity, Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Publisher2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { BaseEntity, Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { BaseEntity, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Sandwich extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { BaseEntity, Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { BaseEntity, Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 extends BaseEntity {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName= entitySchema=true: dump 1`] = `
[
  "import { BaseEntity, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';

export class Address2 extends BaseEntity {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { BaseEntity, Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';

export class Author2 extends BaseEntity {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';

export class BaseUser2 extends BaseEntity {
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';

export class BookTag2 extends BaseEntity {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { BaseEntity, Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

export class Book2 extends BaseEntity {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { BaseEntity, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags extends BaseEntity {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';
import { Car2 } from './Car2';

export class CarOwner2 extends BaseEntity {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { BaseEntity, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';

export class Car2 extends BaseEntity {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { BaseEntity, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Test2 } from './Test2';

export class Configuration2 extends BaseEntity {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';

export class Dummy2 extends BaseEntity {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 extends BaseEntity {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';

export class FooBaz2 extends BaseEntity {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 extends BaseEntity {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';

export class Publisher2 extends BaseEntity {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests extends BaseEntity {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';

export class Sandwich extends BaseEntity {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { BaseEntity, Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

export class Test2 extends BaseEntity {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { BaseEntity, Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

export class User2 extends BaseEntity {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName=BaseEntity entitySchema=false: dump 1`] = `
[
  "import { Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Address2 extends BaseEntity {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class BaseUser2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class BookTag2 extends BaseEntity {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 extends BaseEntity {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags extends BaseEntity {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';

@Entity()
export class CarOwner2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Car2 extends BaseEntity {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 extends BaseEntity {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Entity, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Dummy2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class FooBaz2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 extends BaseEntity {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Publisher2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Sandwich extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 extends BaseEntity {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
  "import { BaseEntity as MikroBaseEntity, Config, type DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroBaseEntity {

  [Config]?: DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName=BaseEntity entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';

export class Address2 extends BaseEntity {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';

export class Author2 extends BaseEntity {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BaseUser2 extends BaseEntity {
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BookTag2 extends BaseEntity {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseEntity } from './BaseEntity';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

export class Book2 extends BaseEntity {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags extends BaseEntity {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';

export class CarOwner2 extends BaseEntity {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Car2 extends BaseEntity {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Test2 } from './Test2';

export class Configuration2 extends BaseEntity {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Dummy2 extends BaseEntity {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 extends BaseEntity {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class FooBaz2 extends BaseEntity {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 extends BaseEntity {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Publisher2 extends BaseEntity {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests extends BaseEntity {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Sandwich extends BaseEntity {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

export class Test2 extends BaseEntity {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

export class User2 extends BaseEntity {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
  "import { BaseEntity as MikroBaseEntity, Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroBaseEntity {
  [Config]?: DefineConfig<{ forceObject: true }>;
}

export const BaseEntitySchema = new EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName=BaseUser2 entitySchema=false: dump 1`] = `
[
  "import { Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Address2 extends BaseUser2 {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { BaseEntity, Config, type DefineConfig, Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';

@Entity()
export class BaseUser2 extends BaseEntity {

  [Config]?: DefineConfig<{ forceObject: true }>;


  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class BookTag2 extends BaseUser2 {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 extends BaseUser2 {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags extends BaseUser2 {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';

@Entity()
export class CarOwner2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Car2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Entity, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Dummy2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class FooBaz2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Publisher2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Sandwich extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 extends BaseUser2 {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName=BaseUser2 entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';

export class Address2 extends BaseUser2 {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';

export class Author2 extends BaseUser2 {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { BaseEntity, Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export class BaseUser2 extends BaseEntity {
  [Config]?: DefineConfig<{ forceObject: true }>;
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class BookTag2 extends BaseUser2 {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BaseUser2 } from './BaseUser2';
import { BookTag2 } from './BookTag2';
import { Publisher2 } from './Publisher2';

export class Book2 extends BaseUser2 {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';

export class Book2Tags extends BaseUser2 {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';

export class CarOwner2 extends BaseUser2 {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Car2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Test2 } from './Test2';

export class Configuration2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Dummy2 extends BaseUser2 {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 extends BaseUser2 {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class FooBaz2 extends BaseUser2 {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Publisher2 extends BaseUser2 {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests extends BaseUser2 {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Sandwich extends BaseUser2 {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book2 } from './Book2';
import { FooBar2 } from './FooBar2';

export class Test2 extends BaseUser2 {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Car2 } from './Car2';
import { Sandwich } from './Sandwich';

export class User2 extends BaseUser2 {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName=CustomBase entitySchema=false: dump 1`] = `
[
  "import { Entity, OneToOne, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { CustomBase } from './CustomBase';

@Entity()
export class Address2 extends CustomBase {

  [PrimaryKeyProp]?: 'author';

  @OneToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'cascade', primary: true })
  author!: Author2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';

@Entity()
@Index({ name: 'author2_name_age_index', properties: ['name', 'age'] })
@Unique({ name: 'author2_name_email_unique', properties: ['name', 'email'] })
export class Author2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  updatedAt!: Date & Opt;

  @Index({ name: 'custom_idx_name_123' })
  @Property({ length: 255 })
  name!: string;

  @Index({ name: 'custom_email_index_name' })
  @Unique({ name: 'custom_email_unique_name' })
  @Property({ length: 255 })
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Index({ name: 'author2_terms_accepted_index' })
  @Property({ type: 'boolean' })
  termsAccepted: boolean & Opt = false;

  @Property({ nullable: true })
  optional?: boolean;

  @Property({ columnType: 'text', nullable: true })
  identities?: string;

  @Index({ name: 'author2_born_index' })
  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Index({ name: 'born_time_idx' })
  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book2, deleteRule: 'cascade', nullable: true })
  favouriteBook?: Book2;

  @ManyToOne({ entity: () => Author2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteAuthor?: Author2;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

  @ManyToMany({ entity: () => Author2, pivotTable: 'author_to_friend', joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  authorToFriend = new Collection<Author2>(this);

  @ManyToMany({ entity: () => Author2, joinColumn: 'author2_1_id', inverseJoinColumn: 'author2_2_id' })
  following = new Collection<Author2>(this);

}
",
  "import { Entity, Enum, Index, ManyToOne, OneToOne, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class BaseUser2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 100 })
  firstName!: string;

  @Property({ length: 100 })
  lastName!: string;

  @Index({ name: 'base_user2_type_index' })
  @Enum({ items: () => BaseUser2Type })
  type!: BaseUser2Type;

  @Property({ length: 255, nullable: true })
  ownerProp?: string;

  @ManyToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteEmployee?: BaseUser2;

  @OneToOne({ entity: () => BaseUser2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteManager?: BaseUser2;

  @Unique({ name: 'base_user2_employee_prop_unique' })
  @Property({ nullable: true })
  employeeProp?: number;

  @Property({ length: 255, nullable: true })
  managerProp?: string;

}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class BookTag2 extends CustomBase {

  @PrimaryKey()
  id!: bigint;

  @Property({ length: 50 })
  name!: string;

}
",
  "import { Collection, Entity, Index, ManyToMany, ManyToOne, type Opt, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';

@Entity()
export class Book2 extends CustomBase {

  [PrimaryKeyProp]?: 'uuidPk';

  @PrimaryKey({ length: 36 })
  uuidPk!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  createdAt!: Date & Opt;

  @Index({ name: 'book2_title_index' })
  @Property({ length: 255, nullable: true })
  title?: string;

  @Property({ columnType: 'text', nullable: true })
  perex?: string;

  @Property({ columnType: 'numeric(8,2)', nullable: true })
  price?: string;

  @Property({ columnType: 'double', nullable: true })
  double?: number;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToOne({ entity: () => Author2 })
  author!: Author2;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade', nullable: true })
  publisher?: Publisher2;

  @Property({ type: 'string', length: 255, nullable: true })
  foo?: string & Opt = 'lol';

  @ManyToMany({ entity: () => BookTag2, pivotTable: 'book_to_tag_unordered', joinColumn: 'book2_uuid_pk', inverseJoinColumn: 'book_tag2_id' })
  bookToTagUnordered = new Collection<BookTag2>(this);

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';

@Entity({ tableName: 'book2_tags' })
export class Book2Tags extends CustomBase {

  [PrimaryKeyProp]?: 'order';

  @PrimaryKey()
  order!: number;

  @ManyToOne({ entity: () => Book2, updateRule: 'cascade', deleteRule: 'cascade' })
  book2!: Book2;

  @ManyToOne({ entity: () => BookTag2, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag2!: BookTag2;

}
",
  "import { Entity, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';

@Entity()
export class CarOwner2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @ManyToOne({ entity: () => Car2, updateRule: 'cascade' })
  car!: Car2;

}
",
  "import { Entity, Index, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Car2 extends CustomBase {

  [PrimaryKeyProp]?: ['name', 'year'];

  @Index({ name: 'car2_name_index' })
  @PrimaryKey({ length: 100 })
  name!: string;

  @Index({ name: 'car2_year_index' })
  @PrimaryKey()
  year!: number;

  @Property()
  price!: number;

}
",
  "import { Entity, ManyToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Test2 } from './Test2';

@Entity()
export class Configuration2 extends CustomBase {

  [PrimaryKeyProp]?: ['property', 'test'];

  @PrimaryKey({ length: 255 })
  property!: string;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', primary: true })
  test!: Test2;

  @Property({ length: 255 })
  value!: string;

}
",
  "import { Entity, PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Dummy2 extends CustomBase {

  @PrimaryKey()
  id!: number;

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooBar2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ fieldName: 'name with space', length: 255, nullable: true })
  nameWithSpace?: string;

  @OneToOne({ entity: () => FooBaz2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz2;

  @OneToOne({ entity: () => FooBar2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` })
  version!: Date & Opt;

  @Property({ length: 65535, nullable: true })
  blob?: Buffer;

  @Property({ length: 65535, nullable: true })
  blob2?: Buffer;

  @Property({ columnType: 'text', nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  objectProperty?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class FooBaz2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, ManyToOne, type Opt, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

@Entity()
export class FooParam2 extends CustomBase {

  [PrimaryKeyProp]?: ['bar', 'baz'];

  @ManyToOne({ entity: () => FooBar2, updateRule: 'cascade', primary: true })
  bar!: FooBar2;

  @ManyToOne({ entity: () => FooBaz2, updateRule: 'cascade', primary: true })
  baz!: FooBaz2;

  @Property({ length: 255 })
  value!: string;

  @Property({ type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Publisher2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ type: 'string', length: 255 })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher2Type })
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;

  @Enum({ items: () => Publisher2Type2 })
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;

  @Property({ columnType: 'tinyint', nullable: true })
  enum1?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum2?: number;

  @Property({ columnType: 'tinyint', nullable: true })
  enum3?: number;

  @Enum({ items: () => Publisher2Enum4, nullable: true })
  enum4?: Publisher2Enum4;

  @Enum({ items: () => Publisher2Enum5, nullable: true })
  enum5?: Publisher2Enum5;

}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

@Entity({ tableName: 'publisher2_tests' })
export class Publisher2Tests extends CustomBase {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher2, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher2!: Publisher2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'cascade' })
  test2!: Test2;

}
",
  "import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Sandwich extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255 })
  name!: string;

  @Property()
  price!: number;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';

@Entity()
export class Test2 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ length: 255, nullable: true })
  name?: string;

  @OneToOne({ entity: () => Book2, deleteRule: 'set null', nullable: true })
  book?: Book2;

  @ManyToOne({ entity: () => Test2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  parent?: Test2;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @OneToOne({ entity: () => FooBar2, fieldName: 'foo___bar', updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar2;

  @Property({ fieldName: 'foo___baz', unsigned: true, nullable: true })
  fooBaz?: number;

  @ManyToMany({ entity: () => FooBar2, joinColumn: 'test2_id', inverseJoinColumn: 'foo_bar2_id' })
  bars = new Collection<FooBar2>(this);

}
",
  "import { Collection, Entity, ManyToMany, OneToOne, PrimaryKey, PrimaryKeyProp, Property } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';
import { Sandwich } from './Sandwich';

@Entity()
export class User2 extends CustomBase {

  [PrimaryKeyProp]?: ['firstName', 'lastName'];

  @PrimaryKey({ length: 100 })
  firstName!: string;

  @PrimaryKey({ length: 100 })
  lastName!: string;

  @Property({ nullable: true })
  foo?: number;

  @OneToOne({ entity: () => Car2, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteCar?: Car2;

  @ManyToMany({ entity: () => Car2, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumns: ['car2_name', 'car2_year'] })
  cars = new Collection<Car2>(this);

  @ManyToMany({ entity: () => Sandwich, joinColumns: ['user2_first_name', 'user2_last_name'], inverseJoinColumn: 'sandwich_id' })
  sandwiches = new Collection<Sandwich>(this);

}
",
  "import { BaseEntity, Config, type DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase extends BaseEntity {

  [Config]?: DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName=CustomBase entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { CustomBase } from './CustomBase';

export class Address2 extends CustomBase {
  [PrimaryKeyProp]?: 'author';
  author!: Author2;
  value!: string;
}

export const Address2Schema = new EntitySchema({
  class: Address2,
  properties: {
    author: {
      primary: true,
      kind: '1:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';

export class Author2 extends CustomBase {
  id!: number;
  createdAt!: Date & Opt;
  updatedAt!: Date & Opt;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: boolean & Opt = false;
  optional?: boolean;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book2;
  favouriteAuthor?: Author2;
  identity?: any;
  authorToFriend = new Collection<Author2>(this);
  following = new Collection<Author2>(this);
}

export const Author2Schema = new EntitySchema({
  class: Author2,
  indexes: [
    { name: 'author2_name_age_index', properties: ['name', 'age'] },
  ],
  uniques: [
    { name: 'author2_name_email_unique', properties: ['name', 'email'] },
  ],
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    updatedAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    name: { type: 'string', length: 255, index: 'custom_idx_name_123' },
    email: {
      type: 'string',
      length: 255,
      index: 'custom_email_index_name',
      unique: 'custom_email_unique_name',
    },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', index: 'author2_terms_accepted_index' },
    optional: { type: 'boolean', nullable: true },
    identities: { type: 'string', columnType: 'text', nullable: true },
    born: {
      type: 'string',
      columnType: 'date',
      nullable: true,
      index: 'author2_born_index',
    },
    bornTime: { type: 'string', columnType: 'time', nullable: true, index: 'born_time_idx' },
    favouriteBook: { kind: 'm:1', entity: () => Book2, deleteRule: 'cascade', nullable: true },
    favouriteAuthor: {
      kind: 'm:1',
      entity: () => Author2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
    authorToFriend: {
      kind: 'm:n',
      entity: () => Author2,
      pivotTable: 'author_to_friend',
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
    following: {
      kind: 'm:n',
      entity: () => Author2,
      joinColumn: 'author2_1_id',
      inverseJoinColumn: 'author2_2_id',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BaseUser2 extends CustomBase {
  id!: number;
  firstName!: string;
  lastName!: string;
  type!: BaseUser2Type;
  ownerProp?: string;
  favouriteEmployee?: BaseUser2;
  favouriteManager?: BaseUser2;
  employeeProp?: number;
  managerProp?: string;
}

export enum BaseUser2Type {
  EMPLOYEE = 'employee',
  MANAGER = 'manager',
  OWNER = 'owner',
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
    id: { primary: true, type: 'number' },
    firstName: { type: 'string', length: 100 },
    lastName: { type: 'string', length: 100 },
    type: { enum: true, items: () => BaseUser2Type, index: 'base_user2_type_index' },
    ownerProp: { type: 'string', length: 255, nullable: true },
    favouriteEmployee: {
      kind: 'm:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    favouriteManager: {
      kind: '1:1',
      entity: () => BaseUser2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    employeeProp: { type: 'number', nullable: true, unique: 'base_user2_employee_prop_unique' },
    managerProp: { type: 'string', length: 255, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BookTag2 extends CustomBase {
  id!: bigint;
  name!: string;
}

export const BookTag2Schema = new EntitySchema({
  class: BookTag2,
  properties: {
    id: { primary: true, type: 'bigint' },
    name: { type: 'string', length: 50 },
  },
});
",
  "import { Collection, EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { Author2 } from './Author2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';

export class Book2 extends CustomBase {
  [PrimaryKeyProp]?: 'uuidPk';
  uuidPk!: string;
  createdAt!: Date & Opt;
  title?: string;
  perex?: string;
  price?: string;
  double?: number;
  meta?: any;
  author!: Author2;
  publisher?: Publisher2;
  foo?: string & Opt = 'lol';
  bookToTagUnordered = new Collection<BookTag2>(this);
}

export const Book2Schema = new EntitySchema({
  class: Book2,
  properties: {
    uuidPk: { primary: true, type: 'string', length: 36 },
    createdAt: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
    title: { type: 'string', length: 255, nullable: true, index: 'book2_title_index' },
    perex: { type: 'string', columnType: 'text', nullable: true },
    price: { type: 'string', columnType: 'numeric(8,2)', nullable: true },
    double: { type: 'number', columnType: 'double', nullable: true },
    meta: { type: 'any', columnType: 'json', nullable: true },
    author: { kind: 'm:1', entity: () => Author2 },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
      nullable: true,
    },
    foo: { type: 'string', length: 255, nullable: true },
    bookToTagUnordered: {
      kind: 'm:n',
      entity: () => BookTag2,
      pivotTable: 'book_to_tag_unordered',
      joinColumn: 'book2_uuid_pk',
      inverseJoinColumn: 'book_tag2_id',
    },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { BookTag2 } from './BookTag2';
import { CustomBase } from './CustomBase';

export class Book2Tags extends CustomBase {
  [PrimaryKeyProp]?: 'order';
  order!: number;
  book2!: Book2;
  bookTag2!: BookTag2;
}

export const Book2TagsSchema = new EntitySchema({
  class: Book2Tags,
  tableName: 'book2_tags',
  properties: {
    order: { primary: true, type: 'number' },
    book2: {
      kind: 'm:1',
      entity: () => Book2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag2: {
      kind: 'm:1',
      entity: () => BookTag2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';

export class CarOwner2 extends CustomBase {
  id!: number;
  name!: string;
  car!: Car2;
}

export const CarOwner2Schema = new EntitySchema({
  class: CarOwner2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    car: { kind: 'm:1', entity: () => Car2, updateRule: 'cascade' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Car2 extends CustomBase {
  [PrimaryKeyProp]?: ['name', 'year'];
  name!: string;
  year!: number;
  price!: number;
}

export const Car2Schema = new EntitySchema({
  class: Car2,
  properties: {
    name: { primary: true, type: 'string', length: 100, index: 'car2_name_index' },
    year: { primary: true, type: 'number', index: 'car2_year_index' },
    price: { type: 'number' },
  },
});
",
  "import { EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Test2 } from './Test2';

export class Configuration2 extends CustomBase {
  [PrimaryKeyProp]?: ['property', 'test'];
  property!: string;
  test!: Test2;
  value!: string;
}

export const Configuration2Schema = new EntitySchema({
  class: Configuration2,
  properties: {
    property: { primary: true, type: 'string', length: 255 },
    test: { primary: true, kind: 'm:1', entity: () => Test2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Dummy2 extends CustomBase {
  id!: number;
}

export const Dummy2Schema = new EntitySchema({
  class: Dummy2,
  properties: {
    id: { primary: true, type: 'number' },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz2 } from './FooBaz2';

export class FooBar2 extends CustomBase {
  id!: number;
  name!: string;
  nameWithSpace?: string;
  baz?: FooBaz2;
  fooBar?: FooBar2;
  version!: Date & Opt;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  objectProperty?: any;
}

export const FooBar2Schema = new EntitySchema({
  class: FooBar2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    nameWithSpace: { type: 'string', fieldName: 'name with space', length: 255, nullable: true },
    baz: {
      kind: '1:1',
      entity: () => FooBaz2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'Date', length: 0, defaultRaw: \`CURRENT_TIMESTAMP\` },
    blob: { type: 'Buffer', length: 65535, nullable: true },
    blob2: { type: 'Buffer', length: 65535, nullable: true },
    array: { type: 'string', columnType: 'text', nullable: true },
    objectProperty: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class FooBaz2 extends CustomBase {
  id!: number;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz2Schema = new EntitySchema({
  class: FooBaz2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt, PrimaryKeyProp } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';
import { FooBaz2 } from './FooBaz2';

export class FooParam2 extends CustomBase {
  [PrimaryKeyProp]?: ['bar', 'baz'];
  bar!: FooBar2;
  baz!: FooBaz2;
  value!: string;
  version!: Date & Opt;
}

export const FooParam2Schema = new EntitySchema({
  class: FooParam2,
  properties: {
    bar: { primary: true, kind: 'm:1', entity: () => FooBar2, updateRule: 'cascade' },
    baz: { primary: true, kind: 'm:1', entity: () => FooBaz2, updateRule: 'cascade' },
    value: { type: 'string', length: 255 },
    version: { type: 'Date', length: 3, defaultRaw: \`current_timestamp(3)\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Publisher2 extends CustomBase {
  id!: number;
  name: string & Opt = 'asd';
  type: Publisher2Type & Opt = Publisher2Type.LOCAL;
  type2: Publisher2Type2 & Opt = Publisher2Type2.LOCAL;
  enum1?: number;
  enum2?: number;
  enum3?: number;
  enum4?: Publisher2Enum4;
  enum5?: Publisher2Enum5;
}

export enum Publisher2Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export enum Publisher2Type2 {
  LOCAL = 'LOCAL',
  GLOBAL = 'GLOBAL',
}

export enum Publisher2Enum4 {
  A = 'a',
  B = 'b',
  C = 'c',
}

export enum Publisher2Enum5 {
  A = 'a',
}

export const Publisher2Schema = new EntitySchema({
  class: Publisher2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    type: { enum: true, items: () => Publisher2Type },
    type2: { enum: true, items: () => Publisher2Type2 },
    enum1: { type: 'number', columnType: 'tinyint', nullable: true },
    enum2: { type: 'number', columnType: 'tinyint', nullable: true },
    enum3: { type: 'number', columnType: 'tinyint', nullable: true },
    enum4: { enum: true, items: () => Publisher2Enum4, nullable: true },
    enum5: { enum: true, items: () => Publisher2Enum5, nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher2 } from './Publisher2';
import { Test2 } from './Test2';

export class Publisher2Tests extends CustomBase {
  id!: number;
  publisher2!: Publisher2;
  test2!: Test2;
}

export const Publisher2TestsSchema = new EntitySchema({
  class: Publisher2Tests,
  tableName: 'publisher2_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher2: {
      kind: 'm:1',
      entity: () => Publisher2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test2: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Sandwich extends CustomBase {
  id!: number;
  name!: string;
  price!: number;
}

export const SandwichSchema = new EntitySchema({
  class: Sandwich,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255 },
    price: { type: 'number' },
  },
});
",
  "import { Collection, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book2 } from './Book2';
import { CustomBase } from './CustomBase';
import { FooBar2 } from './FooBar2';

export class Test2 extends CustomBase {
  id!: number;
  name?: string;
  book?: Book2;
  parent?: Test2;
  version: number & Opt = 1;
  fooBar?: FooBar2;
  fooBaz?: number;
  bars = new Collection<FooBar2>(this);
}

export const Test2Schema = new EntitySchema({
  class: Test2,
  properties: {
    id: { primary: true, type: 'number' },
    name: { type: 'string', length: 255, nullable: true },
    book: { kind: '1:1', entity: () => Book2, deleteRule: 'set null', nullable: true },
    parent: {
      kind: 'm:1',
      entity: () => Test2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar2,
      fieldName: 'foo___bar',
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBaz: { type: 'number', fieldName: 'foo___baz', unsigned: true, nullable: true },
    bars: {
      kind: 'm:n',
      entity: () => FooBar2,
      joinColumn: 'test2_id',
      inverseJoinColumn: 'foo_bar2_id',
    },
  },
});
",
  "import { Collection, EntitySchema, PrimaryKeyProp } from '@mikro-orm/core';
import { Car2 } from './Car2';
import { CustomBase } from './CustomBase';
import { Sandwich } from './Sandwich';

export class User2 extends CustomBase {
  [PrimaryKeyProp]?: ['firstName', 'lastName'];
  firstName!: string;
  lastName!: string;
  foo?: number;
  favouriteCar?: Car2;
  cars = new Collection<Car2>(this);
  sandwiches = new Collection<Sandwich>(this);
}

export const User2Schema = new EntitySchema({
  class: User2,
  properties: {
    firstName: { primary: true, type: 'string', length: 100 },
    lastName: { primary: true, type: 'string', length: 100 },
    foo: { type: 'number', nullable: true },
    favouriteCar: {
      kind: '1:1',
      entity: () => Car2,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    cars: {
      kind: 'm:n',
      entity: () => Car2,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumns: ['car2_name', 'car2_year'],
    },
    sandwiches: {
      kind: 'm:n',
      entity: () => Sandwich,
      joinColumns: ['user2_first_name', 'user2_last_name'],
      inverseJoinColumn: 'sandwich_id',
    },
  },
});
",
  "import { BaseEntity, Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase extends BaseEntity {
  [Config]?: DefineConfig<{ forceObject: true }>;
}

export const CustomBaseSchema = new EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;
