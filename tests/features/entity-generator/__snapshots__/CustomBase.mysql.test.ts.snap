// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName= entitySchema=false: dump 1`] = `
[
  "import { Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book4 } from './Book4';

@Entity()
export class Author4 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class BookTag4 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class FooBaz4 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Publisher4 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@Entity()
export class TagsOrdered {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Test4 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName= entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';

export class Author4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';

export class BookTag4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';

export class FooBaz4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';

export class Publisher4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';

export class Test4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName=BaseEntity entitySchema=false: dump 1`] = `
[
  "import { Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

@Entity()
export class Author4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class BookTag4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class FooBaz4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Publisher4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@Entity()
export class TagsOrdered extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Test4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
  "import { Config, type DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity {

  [Config]?: DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName=BaseEntity entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BookTag4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class FooBaz4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Publisher4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Test4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
  "import { Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity {
  [Config]?: DefineConfig<{ forceObject: false }>;
}

export const BaseEntitySchema = new EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName=BaseUser2 entitySchema=false: dump 1`] = `
[
  "import { Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';

@Entity()
export class Author4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class BookTag4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseUser2 } from './BaseUser2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class FooBaz4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Publisher4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@Entity()
export class TagsOrdered extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Test4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
  "import { Config, type DefineConfig } from '@mikro-orm/core';

export abstract class BaseUser2 {

  [Config]?: DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName=BaseUser2 entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';

export class Author4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class BookTag4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseUser2 } from './BaseUser2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class FooBaz4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Publisher4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseUser2 {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseUser2 {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Test4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
  "import { Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class BaseUser2 {
  [Config]?: DefineConfig<{ forceObject: false }>;
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName=CustomBase entitySchema=false: dump 1`] = `
[
  "import { Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

@Entity()
export class Author4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class BookTag4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class FooBaz4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Publisher4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends CustomBase {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

@Entity()
export class TagsOrdered extends CustomBase {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Test4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
  "import { Config, type DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase {

  [Config]?: DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=false customBaseEntityName=CustomBase entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

export class Author4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BookTag4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

export class Book4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class FooBaz4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Publisher4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends CustomBase {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

export class TagsOrdered extends CustomBase {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Test4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
  "import { Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase {
  [Config]?: DefineConfig<{ forceObject: false }>;
}

export const CustomBaseSchema = new EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName= entitySchema=false: dump 1`] = `
[
  "import { BaseEntity, Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book4 } from './Book4';

@Entity()
export class Author4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { BaseEntity, Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class BookTag4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { BaseEntity, Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { BaseEntity, Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { BaseEntity, Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class FooBaz4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { BaseEntity, Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Publisher4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { BaseEntity, Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { BaseEntity, Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@Entity()
export class TagsOrdered extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { BaseEntity, Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Test4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName= entitySchema=true: dump 1`] = `
[
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';

export class BookTag4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { BaseEntity, Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';

export class FooBaz4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';

export class Publisher4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';

export class Test4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName=BaseEntity entitySchema=false: dump 1`] = `
[
  "import { Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

@Entity()
export class Author4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class BookTag4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class FooBaz4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Publisher4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@Entity()
export class TagsOrdered extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Test4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
  "import { BaseEntity as MikroBaseEntity, Config, type DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroBaseEntity {

  [Config]?: DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName=BaseEntity entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BookTag4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class FooBaz4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Publisher4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Test4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
  "import { BaseEntity as MikroBaseEntity, Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroBaseEntity {
  [Config]?: DefineConfig<{ forceObject: false }>;
}

export const BaseEntitySchema = new EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName=BaseUser2 entitySchema=false: dump 1`] = `
[
  "import { Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';

@Entity()
export class Author4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class BookTag4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseUser2 } from './BaseUser2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class FooBaz4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Publisher4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@Entity()
export class TagsOrdered extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Test4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
  "import { BaseEntity, Config, type DefineConfig } from '@mikro-orm/core';

export abstract class BaseUser2 extends BaseEntity {

  [Config]?: DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName=BaseUser2 entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';

export class Author4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class BookTag4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseUser2 } from './BaseUser2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class FooBaz4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Publisher4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseUser2 {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseUser2 {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Test4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
  "import { BaseEntity, Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class BaseUser2 extends BaseEntity {
  [Config]?: DefineConfig<{ forceObject: false }>;
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName=CustomBase entitySchema=false: dump 1`] = `
[
  "import { Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

@Entity()
export class Author4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class BookTag4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class FooBaz4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Publisher4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends CustomBase {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

@Entity()
export class TagsOrdered extends CustomBase {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Test4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
  "import { BaseEntity, Config, type DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase extends BaseEntity {

  [Config]?: DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase forceObject=false useCoreBaseEntity=true customBaseEntityName=CustomBase entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

export class Author4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BookTag4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

export class Book4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class FooBaz4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Publisher4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends CustomBase {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

export class TagsOrdered extends CustomBase {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Test4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
  "import { BaseEntity, Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase extends BaseEntity {
  [Config]?: DefineConfig<{ forceObject: false }>;
}

export const CustomBaseSchema = new EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName= entitySchema=false: dump 1`] = `
[
  "import { Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book4 } from './Book4';

@Entity()
export class Author4 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class BookTag4 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class FooBaz4 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Publisher4 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@Entity()
export class TagsOrdered {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Test4 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName= entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';

export class Author4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';

export class BookTag4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';

export class FooBaz4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';

export class Publisher4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';

export class Test4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName=BaseEntity entitySchema=false: dump 1`] = `
[
  "import { Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

@Entity()
export class Author4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class BookTag4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class FooBaz4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Publisher4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@Entity()
export class TagsOrdered extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Test4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
  "import { Config, type DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity {

  [Config]?: DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName=BaseEntity entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BookTag4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class FooBaz4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Publisher4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Test4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
  "import { Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity {
  [Config]?: DefineConfig<{ forceObject: true }>;
}

export const BaseEntitySchema = new EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName=BaseUser2 entitySchema=false: dump 1`] = `
[
  "import { Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';

@Entity()
export class Author4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class BookTag4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseUser2 } from './BaseUser2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class FooBaz4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Publisher4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@Entity()
export class TagsOrdered extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Test4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
  "import { Config, type DefineConfig } from '@mikro-orm/core';

export abstract class BaseUser2 {

  [Config]?: DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName=BaseUser2 entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';

export class Author4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class BookTag4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseUser2 } from './BaseUser2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class FooBaz4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Publisher4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseUser2 {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseUser2 {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Test4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
  "import { Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class BaseUser2 {
  [Config]?: DefineConfig<{ forceObject: true }>;
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName=CustomBase entitySchema=false: dump 1`] = `
[
  "import { Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

@Entity()
export class Author4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class BookTag4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class FooBaz4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Publisher4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends CustomBase {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

@Entity()
export class TagsOrdered extends CustomBase {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Test4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
  "import { Config, type DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase {

  [Config]?: DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=false customBaseEntityName=CustomBase entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

export class Author4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BookTag4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

export class Book4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class FooBaz4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Publisher4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends CustomBase {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

export class TagsOrdered extends CustomBase {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Test4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
  "import { Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase {
  [Config]?: DefineConfig<{ forceObject: true }>;
}

export const CustomBaseSchema = new EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName= entitySchema=false: dump 1`] = `
[
  "import { BaseEntity, Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book4 } from './Book4';

@Entity()
export class Author4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { BaseEntity, Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class BookTag4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { BaseEntity, Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { BaseEntity, Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { BaseEntity, Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class FooBaz4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { BaseEntity, Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Publisher4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { BaseEntity, Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { BaseEntity, Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@Entity()
export class TagsOrdered extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { BaseEntity, Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class Test4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName= entitySchema=true: dump 1`] = `
[
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';

export class BookTag4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { BaseEntity, Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';

export class FooBaz4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';

export class Publisher4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity, EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity, EntitySchema, type Opt } from '@mikro-orm/core';

export class Test4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName=BaseEntity entitySchema=false: dump 1`] = `
[
  "import { Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

@Entity()
export class Author4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class BookTag4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class FooBaz4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Publisher4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@Entity()
export class TagsOrdered extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@Entity()
export class Test4 extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
  "import { BaseEntity as MikroBaseEntity, Config, type DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroBaseEntity {

  [Config]?: DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName=BaseEntity entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BookTag4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class FooBaz4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Publisher4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Test4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
  "import { BaseEntity as MikroBaseEntity, Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroBaseEntity {
  [Config]?: DefineConfig<{ forceObject: true }>;
}

export const BaseEntitySchema = new EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName=BaseUser2 entitySchema=false: dump 1`] = `
[
  "import { Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';

@Entity()
export class Author4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class BookTag4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseUser2 } from './BaseUser2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class FooBaz4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Publisher4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@Entity()
export class TagsOrdered extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

@Entity()
export class Test4 extends BaseUser2 {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
  "import { BaseEntity, Config, type DefineConfig } from '@mikro-orm/core';

export abstract class BaseUser2 extends BaseEntity {

  [Config]?: DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName=BaseUser2 entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';

export class Author4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class BookTag4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseUser2 } from './BaseUser2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class FooBaz4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Publisher4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseUser2 {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseUser2 {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { BaseUser2 } from './BaseUser2';

export class Test4 extends BaseUser2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
  "import { BaseEntity, Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class BaseUser2 extends BaseEntity {
  [Config]?: DefineConfig<{ forceObject: true }>;
}

export const BaseUser2Schema = new EntitySchema({
  class: BaseUser2,
  properties: {
  },
});
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName=CustomBase entitySchema=false: dump 1`] = `
[
  "import { Entity, ManyToOne, type Opt, PrimaryKey, Property, Unique } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

@Entity()
export class Author4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Unique({ name: 'author4_email_unique' })
  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property({ type: 'number' })
  termsAccepted: number & Opt = 0;

  @Property({ nullable: true })
  identities?: string;

  @Property({ columnType: 'date', nullable: true })
  born?: string;

  @Property({ columnType: 'time', nullable: true })
  bornTime?: string;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @Property({ columnType: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class BookTag4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Collection, Entity, ManyToMany, ManyToOne, PrimaryKey, Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

@Entity()
export class Book4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  title!: string;

  @Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @Property({ columnType: 'json', nullable: true })
  meta?: any;

  @ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new Collection<BookTag4>(this);

}
",
  "import { Entity, OneToOne, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

@Entity()
export class FooBar4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @Property({ type: 'number' })
  version: number & Opt = 1;

  @Property({ nullable: true })
  blob?: Buffer;

  @Property({ nullable: true })
  blob2?: Buffer;

  @Property({ nullable: true })
  array?: string;

  @Property({ columnType: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class FooBaz4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property()
  name!: string;

  @Property({ type: 'Date', defaultRaw: \`current_timestamp\` })
  version!: Date & Opt;

}
",
  "import { Entity, Enum, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Publisher4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ type: 'string' })
  name: string & Opt = 'asd';

  @Enum({ items: () => Publisher4Type })
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;

  @Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends CustomBase {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity, ManyToOne, PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

@Entity()
export class TagsOrdered extends CustomBase {

  @PrimaryKey()
  id!: number;

  @ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity, type Opt, PrimaryKey, Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@Entity()
export class Test4 extends CustomBase {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  createdAt?: Date;

  @Property({ nullable: true })
  updatedAt?: Date;

  @Property({ nullable: true })
  name?: string;

  @Property({ type: 'number' })
  version: number & Opt = 1;

}
",
  "import { BaseEntity, Config, type DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase extends BaseEntity {

  [Config]?: DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase forceObject=true useCoreBaseEntity=true customBaseEntityName=CustomBase entitySchema=true: dump 1`] = `
[
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

export class Author4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    email: { type: 'string', unique: 'author4_email_unique' },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'number' },
    identities: { type: 'string', nullable: true },
    born: { type: 'string', columnType: 'date', nullable: true },
    bornTime: { type: 'string', columnType: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BookTag4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const BookTag4Schema = new EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection, EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

export class Book4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new Collection<BookTag4>(this);
}

export const Book4Schema = new EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    title: { type: 'string' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'any', columnType: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'number' },
    blob: { type: 'Buffer', nullable: true },
    blob2: { type: 'Buffer', nullable: true },
    array: { type: 'string', nullable: true },
    object: { type: 'any', columnType: 'json', nullable: true },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class FooBaz4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & Opt;
}

export const FooBaz4Schema = new EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    version: { type: 'Date', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Publisher4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & Opt = 'asd';
  type: Publisher4Type & Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'number', nullable: true },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends CustomBase {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'number' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

export class TagsOrdered extends CustomBase {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'number' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema, type Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Test4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & Opt = 1;
}

export const Test4Schema = new EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'number' },
    createdAt: { type: 'Date', nullable: true },
    updatedAt: { type: 'Date', nullable: true },
    name: { type: 'string', nullable: true },
    version: { type: 'number' },
  },
});
",
  "import { BaseEntity, Config, type DefineConfig, EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase extends BaseEntity {
  [Config]?: DefineConfig<{ forceObject: true }>;
}

export const CustomBaseSchema = new EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;
