// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName= > decorators > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';

export abstract class BaseEntity2 {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName= > entitySchema > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';

export class Author4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { FooBar4 } from './FooBar4';

export class FooBaz4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests {
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered {
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName=BaseEntity > decorators > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName=BaseEntity > entitySchema > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBar4 } from './FooBar4';

export class FooBaz4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity {
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity {
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity {
}

export const BaseEntitySchema = new MikroORM_EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName=BaseEntity2 > decorators > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';
import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';

export abstract class BaseEntity2 {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;


  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName=BaseEntity2 > entitySchema > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBar4 } from './FooBar4';

export class FooBaz4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity2 {
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity2 {
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName=CustomBase > decorators > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Author4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class TagsOrdered extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName=CustomBase > entitySchema > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

export class Author4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBar4 } from './FooBar4';

export class FooBaz4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends CustomBase {
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

export class TagsOrdered extends CustomBase {
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase {
}

export const CustomBaseSchema = new MikroORM_EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName= > decorators > dump 1`] = `
[
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { BaseEntity as MikroORM_BaseEntity, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { BaseEntity as MikroORM_BaseEntity, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { BaseEntity as MikroORM_BaseEntity } from '@mikro-orm/core';
import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName= > entitySchema > dump 1`] = `
[
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';

export class Author4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { FooBar4 } from './FooBar4';

export class FooBaz4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends MikroORM_BaseEntity {
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends MikroORM_BaseEntity {
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName=BaseEntity > decorators > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroORM_BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName=BaseEntity > entitySchema > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBar4 } from './FooBar4';

export class FooBaz4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity {
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity {
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroORM_BaseEntity {
}

export const BaseEntitySchema = new MikroORM_EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName=BaseEntity2 > decorators > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';
import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;


  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName=BaseEntity2 > entitySchema > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBar4 } from './FooBar4';

export class FooBaz4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity2 {
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity2 {
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName=CustomBase > decorators > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Author4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class TagsOrdered extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase extends MikroORM_BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName=CustomBase > entitySchema > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

export class Author4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBar4 } from './FooBar4';

export class FooBaz4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends CustomBase {
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

export class TagsOrdered extends CustomBase {
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase extends MikroORM_BaseEntity {
}

export const CustomBaseSchema = new MikroORM_EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName= > decorators > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';

export abstract class BaseEntity2 {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName= > entitySchema > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';

export class Author4 {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { Collection as MikroORM_Collection, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { FooBar4 } from './FooBar4';

export class FooBaz4 {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { Collection as MikroORM_Collection, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName=BaseEntity > decorators > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName=BaseEntity > entitySchema > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBar4 } from './FooBar4';

export class FooBaz4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity {
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity {
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
}

export const BaseEntitySchema = new MikroORM_EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName=BaseEntity2 > decorators > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';
import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';

export abstract class BaseEntity2 {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;


  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName=BaseEntity2 > entitySchema > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBar4 } from './FooBar4';

export class FooBaz4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity2 {
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity2 {
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName=CustomBase > decorators > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Author4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class TagsOrdered extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName=CustomBase > entitySchema > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

export class Author4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBar4 } from './FooBar4';

export class FooBaz4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends CustomBase {
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

export class TagsOrdered extends CustomBase {
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
}

export const CustomBaseSchema = new MikroORM_EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName= > decorators > dump 1`] = `
[
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { BaseEntity as MikroORM_BaseEntity, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { BaseEntity as MikroORM_BaseEntity, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { BaseEntity as MikroORM_BaseEntity } from '@mikro-orm/core';
import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName= > entitySchema > dump 1`] = `
[
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';

export class Author4 extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { FooBar4 } from './FooBar4';

export class FooBaz4 extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName=BaseEntity > decorators > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroORM_BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName=BaseEntity > entitySchema > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBar4 } from './FooBar4';

export class FooBaz4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity {
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity {
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
}

export const BaseEntitySchema = new MikroORM_EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName=BaseEntity2 > decorators > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';
import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;


  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName=BaseEntity2 > entitySchema > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBar4 } from './FooBar4';

export class FooBaz4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity2 {
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity2 {
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName=CustomBase > decorators > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Author4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: MikroORM_Ref<Book4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'author' })
  book4Collection = new MikroORM_Collection<Book4>(this);

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, ManyToMany as MikroORM_ManyToMany, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class BookTag4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_ManyToMany({ entity: () => Book4, mappedBy: 'tagsUnordered' })
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'bookTag4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { Collection as MikroORM_Collection, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

@MikroORM_Entity()
export class Book4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: MikroORM_Ref<Author4>;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: MikroORM_Ref<Publisher4>;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

  @MikroORM_OneToMany({ entity: () => Author4, mappedBy: 'favouriteBook' })
  author4Collection = new MikroORM_Collection<Author4>(this);

  @MikroORM_OneToMany({ entity: () => TagsOrdered, mappedBy: 'book4' })
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: MikroORM_Ref<FooBaz4>;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: MikroORM_Ref<FooBar4>;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'fooBar' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { FooBar4 } from './FooBar4';

@MikroORM_Entity()
export class FooBaz4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

  @MikroORM_OneToOne({ entity: () => FooBar4, ref: true, mappedBy: 'baz' })
  fooBar4?: MikroORM_Ref<FooBar4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Publisher4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

  @MikroORM_OneToMany({ entity: () => Book4, mappedBy: 'publisher' })
  book4Collection = new MikroORM_Collection<Book4>(this);

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'publisher4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: MikroORM_Ref<Publisher4>;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: MikroORM_Ref<Test4>;

}
",
  "import { type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/decorators/legacy';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class TagsOrdered extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: MikroORM_Ref<Book4>;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, ref: true, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: MikroORM_Ref<BookTag4>;

}
",
  "import { Collection as MikroORM_Collection, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Entity as MikroORM_Entity, OneToMany as MikroORM_OneToMany, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

@MikroORM_Entity()
export class Test4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_OneToMany({ entity: () => Publisher4Tests, mappedBy: 'test4' })
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/decorators/legacy';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase extends MikroORM_BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName=CustomBase > entitySchema > dump 1`] = `
[
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

export class Author4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: MikroORM_Ref<Book4>;
  identity?: any;
  book4Collection = new MikroORM_Collection<Book4>(this);
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'author' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { TagsOrdered } from './TagsOrdered';

export class BookTag4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  tagsUnorderedInverse = new MikroORM_Collection<Book4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    tagsUnorderedInverse: {
      kind: 'm:n',
      entity: () => Book4,
      mappedBy: 'tagsUnordered',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'bookTag4',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { TagsOrdered } from './TagsOrdered';

export class Book4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: MikroORM_Ref<Author4>;
  publisher?: MikroORM_Ref<Publisher4>;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
  author4Collection = new MikroORM_Collection<Author4>(this);
  tagsOrderedCollection = new MikroORM_Collection<TagsOrdered>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
    author4Collection: {
      kind: '1:m',
      entity: () => Author4,
      mappedBy: 'favouriteBook',
    },
    tagsOrderedCollection: {
      kind: '1:m',
      entity: () => TagsOrdered,
      mappedBy: 'book4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: MikroORM_Ref<FooBaz4>;
  fooBar?: MikroORM_Ref<FooBar4>;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'fooBar' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBar4 } from './FooBar4';

export class FooBaz4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
  fooBar4?: MikroORM_Ref<FooBar4>;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
    fooBar4: { kind: '1:1', entity: () => FooBar4, ref: true, mappedBy: 'baz' },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

export class Publisher4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: TPublisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
  book4Collection = new MikroORM_Collection<Book4>(this);
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Publisher4Type = {
  LOCAL: 'local',
  GLOBAL: 'global',
} as const;

export type TPublisher4Type = (typeof Publisher4Type)[keyof typeof Publisher4Type];

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
    book4Collection: { kind: '1:m', entity: () => Book4, mappedBy: 'publisher' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'publisher4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends CustomBase {
  id!: number;
  publisher4!: MikroORM_Ref<Publisher4>;
  test4!: MikroORM_Ref<Test4>;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Ref as MikroORM_Ref } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

export class TagsOrdered extends CustomBase {
  id!: number;
  book4!: MikroORM_Ref<Book4>;
  bookTag4!: MikroORM_Ref<BookTag4>;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      ref: true,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4Tests } from './Publisher4Tests';

export class Test4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
  publisher4TestsCollection = new MikroORM_Collection<Publisher4Tests>(this);
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
    publisher4TestsCollection: {
      kind: '1:m',
      entity: () => Publisher4Tests,
      mappedBy: 'test4',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
}

export const CustomBaseSchema = new MikroORM_EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;
