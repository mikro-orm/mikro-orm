// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName= > entitySchema=false > dump 1`] = `
[
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class BookTag4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class FooBaz4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class Publisher4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class Test4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/core';

export abstract class BaseEntity2 {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName= > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';

export class Author4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class BookTag4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class FooBaz4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class Publisher4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class Test4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName=BaseEntity > entitySchema=false > dump 1`] = `
[
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class Test4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName=BaseEntity > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BookTag4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class FooBaz4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Publisher4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Test4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;
}

export const BaseEntitySchema = new MikroORM_EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName=BaseEntity2 > entitySchema=false > dump 1`] = `
[
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class Test4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, Formula as MikroORM_Formula } from '@mikro-orm/core';

export abstract class BaseEntity2 {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;


  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName=BaseEntity2 > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class BookTag4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class FooBaz4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class Publisher4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity2 {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity2 {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class Test4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName=CustomBase > entitySchema=false > dump 1`] = `
[
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Author4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class BookTag4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class FooBaz4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Publisher4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class TagsOrdered extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Test4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=false > customBaseEntityName=CustomBase > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

export class Author4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BookTag4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

export class Book4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class FooBaz4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Publisher4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends CustomBase {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

export class TagsOrdered extends CustomBase {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Test4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;
}

export const CustomBaseSchema = new MikroORM_EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName= > entitySchema=false > dump 1`] = `
[
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class BookTag4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class FooBaz4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class Publisher4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class Test4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Formula as MikroORM_Formula } from '@mikro-orm/core';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName= > entitySchema=true > dump 1`] = `
[
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';

export class Author4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class BookTag4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class FooBaz4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class Publisher4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends MikroORM_BaseEntity {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends MikroORM_BaseEntity {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class Test4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName=BaseEntity > entitySchema=false > dump 1`] = `
[
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class Test4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroORM_BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName=BaseEntity > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BookTag4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class FooBaz4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Publisher4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Test4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;
}

export const BaseEntitySchema = new MikroORM_EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName=BaseEntity2 > entitySchema=false > dump 1`] = `
[
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class Test4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, Formula as MikroORM_Formula } from '@mikro-orm/core';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;


  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName=BaseEntity2 > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class BookTag4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class FooBaz4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class Publisher4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity2 {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity2 {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class Test4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName=CustomBase > entitySchema=false > dump 1`] = `
[
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Author4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class BookTag4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class FooBaz4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Publisher4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class TagsOrdered extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Test4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase extends MikroORM_BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;

}
",
]
`;

exports[`CustomBase > forceObject=false > useCoreBaseEntity=true > customBaseEntityName=CustomBase > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

export class Author4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BookTag4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

export class Book4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class FooBaz4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Publisher4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends CustomBase {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

export class TagsOrdered extends CustomBase {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Test4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: false }>;
}

export const CustomBaseSchema = new MikroORM_EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName= > entitySchema=false > dump 1`] = `
[
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class BookTag4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class FooBaz4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class Publisher4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class Test4 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/core';

export abstract class BaseEntity2 {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName= > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';

export class Author4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class BookTag4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class FooBaz4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class Publisher4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class Test4 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName=BaseEntity > entitySchema=false > dump 1`] = `
[
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class Test4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName=BaseEntity > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BookTag4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class FooBaz4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Publisher4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Test4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
}

export const BaseEntitySchema = new MikroORM_EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName=BaseEntity2 > entitySchema=false > dump 1`] = `
[
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class Test4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, Formula as MikroORM_Formula } from '@mikro-orm/core';

export abstract class BaseEntity2 {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;


  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName=BaseEntity2 > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class BookTag4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class FooBaz4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class Publisher4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity2 {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity2 {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class Test4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName=CustomBase > entitySchema=false > dump 1`] = `
[
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Author4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class BookTag4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class FooBaz4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Publisher4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class TagsOrdered extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Test4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=false > customBaseEntityName=CustomBase > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

export class Author4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BookTag4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

export class Book4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class FooBaz4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Publisher4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends CustomBase {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

export class TagsOrdered extends CustomBase {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Test4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
}

export const CustomBaseSchema = new MikroORM_EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName= > entitySchema=false > dump 1`] = `
[
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class BookTag4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class FooBaz4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class Publisher4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';

@MikroORM_Entity()
export class Test4 extends MikroORM_BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Formula as MikroORM_Formula } from '@mikro-orm/core';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName= > entitySchema=true > dump 1`] = `
[
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';

export class Author4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class BookTag4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class FooBaz4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class Publisher4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends MikroORM_BaseEntity {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends MikroORM_BaseEntity {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';

export class Test4 extends MikroORM_BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName=BaseEntity > entitySchema=false > dump 1`] = `
[
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

@MikroORM_Entity()
export class Test4 extends BaseEntity {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroORM_BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName=BaseEntity > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class BookTag4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity } from './BaseEntity';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class FooBaz4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Publisher4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export class Test4 extends BaseEntity {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity } from './BaseEntity';

export abstract class BaseEntity2 extends BaseEntity {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
}

export const BaseEntitySchema = new MikroORM_EntitySchema({
  class: BaseEntity,
  properties: {
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName=BaseEntity2 > entitySchema=false > dump 1`] = `
[
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

@MikroORM_Entity()
export class Author4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class BookTag4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class FooBaz4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class Publisher4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

@MikroORM_Entity()
export class TagsOrdered extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

@MikroORM_Entity()
export class Test4 extends BaseEntity2 {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, Formula as MikroORM_Formula } from '@mikro-orm/core';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;


  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName=BaseEntity2 > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';

export class Author4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class BookTag4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BaseEntity2 } from './BaseEntity2';
import { BookTag4 } from './BookTag4';
import { Publisher4 } from './Publisher4';

export class Book4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class FooBaz4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class Publisher4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends BaseEntity2 {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';

export class TagsOrdered extends BaseEntity2 {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { BaseEntity2 } from './BaseEntity2';

export class Test4 extends BaseEntity2 {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class BaseEntity2 extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName=CustomBase > entitySchema=false > dump 1`] = `
[
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Author4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'text', unique: true })
  email!: string;

  @MikroORM_Property({ nullable: true })
  age?: number;

  @MikroORM_Property({ type: 'integer' })
  termsAccepted: number & MikroORM_Opt = 0;

  @MikroORM_Property({ type: 'text', nullable: true })
  identities?: string;

  @MikroORM_Property({ type: 'date', nullable: true })
  born?: string;

  @MikroORM_Property({ type: 'time', nullable: true })
  bornTime?: string;

  @MikroORM_Index({ name: 'author4_favourite_book_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  favouriteBook?: Book4;

  @MikroORM_Property({ type: 'json', nullable: true })
  identity?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class BookTag4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Collection as MikroORM_Collection, Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToMany as MikroORM_ManyToMany, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

@MikroORM_Entity()
export class Book4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  title!: string;

  @MikroORM_Property({ columnType: 'REAL', nullable: true })
  price?: unknown;

  @MikroORM_Index({ name: 'book4_author_id_index' })
  @MikroORM_ManyToOne({ entity: () => Author4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  author?: Author4;

  @MikroORM_Index({ name: 'book4_publisher_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  publisher?: Publisher4;

  @MikroORM_Property({ type: 'json', nullable: true })
  meta?: any;

  @MikroORM_ManyToMany({ entity: () => BookTag4, pivotTable: 'tags_unordered', joinColumn: 'book4_id', inverseJoinColumn: 'book_tag4_id' })
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);

}
",
  "import { Entity as MikroORM_Entity, OneToOne as MikroORM_OneToOne, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property, Unique as MikroORM_Unique } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

@MikroORM_Entity()
export class FooBar4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Unique({ name: 'foo_bar4_baz_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBaz4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  baz?: FooBaz4;

  @MikroORM_Unique({ name: 'foo_bar4_foo_bar_id_unique' })
  @MikroORM_OneToOne({ entity: () => FooBar4, updateRule: 'cascade', deleteRule: 'set null', nullable: true })
  fooBar?: FooBar4;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

  @MikroORM_Property({ nullable: true })
  blob?: Buffer;

  @MikroORM_Property({ nullable: true })
  blob2?: Buffer;

  @MikroORM_Property({ type: 'text', nullable: true })
  array?: string;

  @MikroORM_Property({ type: 'json', nullable: true })
  object?: any;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class FooBaz4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name!: string;

  @MikroORM_Property({ type: 'datetime', defaultRaw: \`current_timestamp\` })
  version!: Date & MikroORM_Opt;

}
",
  "import { Entity as MikroORM_Entity, Enum as MikroORM_Enum, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Publisher4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text' })
  name: string & MikroORM_Opt = 'asd';

  @MikroORM_Enum({ items: () => Publisher4Type })
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;

  @MikroORM_Property({ nullable: true })
  enum3?: number;

}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

@MikroORM_Entity({ tableName: 'publisher4_tests' })
export class Publisher4Tests extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'publisher4_tests_publisher4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Publisher4, updateRule: 'cascade', deleteRule: 'cascade' })
  publisher4!: Publisher4;

  @MikroORM_Index({ name: 'publisher4_tests_test4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Test4, updateRule: 'cascade', deleteRule: 'cascade' })
  test4!: Test4;

}
",
  "import { Entity as MikroORM_Entity, Index as MikroORM_Index, ManyToOne as MikroORM_ManyToOne, PrimaryKey as MikroORM_PrimaryKey } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class TagsOrdered extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Index({ name: 'tags_ordered_book4_id_index' })
  @MikroORM_ManyToOne({ entity: () => Book4, updateRule: 'cascade', deleteRule: 'cascade' })
  book4!: Book4;

  @MikroORM_Index({ name: 'tags_ordered_book_tag4_id_index' })
  @MikroORM_ManyToOne({ entity: () => BookTag4, updateRule: 'cascade', deleteRule: 'cascade' })
  bookTag4!: BookTag4;

}
",
  "import { Entity as MikroORM_Entity, type Opt as MikroORM_Opt, PrimaryKey as MikroORM_PrimaryKey, Property as MikroORM_Property } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

@MikroORM_Entity()
export class Test4 extends CustomBase {

  @MikroORM_PrimaryKey()
  id!: number;

  @MikroORM_Property({ nullable: true })
  createdAt?: Date;

  @MikroORM_Property({ nullable: true })
  updatedAt?: Date;

  @MikroORM_Property({ type: 'text', nullable: true })
  name?: string;

  @MikroORM_Property({ type: 'integer' })
  version: number & MikroORM_Opt = 1;

}
",
  "import { Formula as MikroORM_Formula } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {

  @MikroORM_Formula(()=>'SELECT NOW()')
  serverTime!: Date;

}
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig } from '@mikro-orm/core';

export abstract class CustomBase extends MikroORM_BaseEntity {

  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;

}
",
]
`;

exports[`CustomBase > forceObject=true > useCoreBaseEntity=true > customBaseEntityName=CustomBase > entitySchema=true > dump 1`] = `
[
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { CustomBase } from './CustomBase';

export class Author4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  email!: string;
  age?: number;
  termsAccepted: number & MikroORM_Opt = 0;
  identities?: string;
  born?: string;
  bornTime?: string;
  favouriteBook?: Book4;
  identity?: any;
}

export const Author4Schema = new MikroORM_EntitySchema({
  class: Author4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    email: { type: 'text', unique: 'author4_email_unique' },
    age: { type: 'integer', nullable: true },
    termsAccepted: { type: 'integer' },
    identities: { type: 'text', nullable: true },
    born: { type: 'date', nullable: true },
    bornTime: { type: 'time', nullable: true },
    favouriteBook: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    identity: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class BookTag4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const BookTag4Schema = new MikroORM_EntitySchema({
  class: BookTag4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { Collection as MikroORM_Collection, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Author4 } from './Author4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';

export class Book4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  title!: string;
  price?: unknown;
  author?: Author4;
  publisher?: Publisher4;
  meta?: any;
  tagsUnordered = new MikroORM_Collection<BookTag4>(this);
}

export const Book4Schema = new MikroORM_EntitySchema({
  class: Book4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    title: { type: 'text' },
    price: { type: 'unknown', columnType: 'REAL', nullable: true },
    author: {
      kind: 'm:1',
      entity: () => Author4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    publisher: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    meta: { type: 'json', nullable: true },
    tagsUnordered: {
      kind: 'm:n',
      entity: () => BookTag4,
      pivotTable: 'tags_unordered',
      joinColumn: 'book4_id',
      inverseJoinColumn: 'book_tag4_id',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { FooBaz4 } from './FooBaz4';

export class FooBar4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  baz?: FooBaz4;
  fooBar?: FooBar4;
  version: number & MikroORM_Opt = 1;
  blob?: Buffer;
  blob2?: Buffer;
  array?: string;
  object?: any;
}

export const FooBar4Schema = new MikroORM_EntitySchema({
  class: FooBar4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    baz: {
      kind: '1:1',
      entity: () => FooBaz4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    fooBar: {
      kind: '1:1',
      entity: () => FooBar4,
      updateRule: 'cascade',
      deleteRule: 'set null',
      nullable: true,
    },
    version: { type: 'integer' },
    blob: { type: 'blob', nullable: true },
    blob2: { type: 'blob', nullable: true },
    array: { type: 'text', nullable: true },
    object: { type: 'json', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class FooBaz4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name!: string;
  version!: Date & MikroORM_Opt;
}

export const FooBaz4Schema = new MikroORM_EntitySchema({
  class: FooBaz4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    version: { type: 'datetime', defaultRaw: \`current_timestamp\` },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Publisher4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name: string & MikroORM_Opt = 'asd';
  type: Publisher4Type & MikroORM_Opt = Publisher4Type.LOCAL;
  enum3?: number;
}

export enum Publisher4Type {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const Publisher4Schema = new MikroORM_EntitySchema({
  class: Publisher4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text' },
    type: { enum: true, items: () => Publisher4Type },
    enum3: { type: 'integer', nullable: true },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';
import { Publisher4 } from './Publisher4';
import { Test4 } from './Test4';

export class Publisher4Tests extends CustomBase {
  id!: number;
  publisher4!: Publisher4;
  test4!: Test4;
}

export const Publisher4TestsSchema = new MikroORM_EntitySchema({
  class: Publisher4Tests,
  tableName: 'publisher4_tests',
  properties: {
    id: { primary: true, type: 'integer' },
    publisher4: {
      kind: 'm:1',
      entity: () => Publisher4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    test4: {
      kind: 'm:1',
      entity: () => Test4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { Book4 } from './Book4';
import { BookTag4 } from './BookTag4';
import { CustomBase } from './CustomBase';

export class TagsOrdered extends CustomBase {
  id!: number;
  book4!: Book4;
  bookTag4!: BookTag4;
}

export const TagsOrderedSchema = new MikroORM_EntitySchema({
  class: TagsOrdered,
  properties: {
    id: { primary: true, type: 'integer' },
    book4: {
      kind: 'm:1',
      entity: () => Book4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
    bookTag4: {
      kind: 'm:1',
      entity: () => BookTag4,
      updateRule: 'cascade',
      deleteRule: 'cascade',
    },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema, type Opt as MikroORM_Opt } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export class Test4 extends CustomBase {
  id!: number;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
  version: number & MikroORM_Opt = 1;
}

export const Test4Schema = new MikroORM_EntitySchema({
  class: Test4,
  properties: {
    id: { primary: true, type: 'integer' },
    createdAt: { type: 'datetime', nullable: true },
    updatedAt: { type: 'datetime', nullable: true },
    name: { type: 'text', nullable: true },
    version: { type: 'integer' },
  },
});
",
  "import { EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';
import { CustomBase } from './CustomBase';

export abstract class BaseEntity2 extends CustomBase {
  serverTime!: Date;
}

export const BaseEntity2Schema = new MikroORM_EntitySchema({
  class: BaseEntity2,
  properties: {
    serverTime: { type: 'datetime', formula: ()=>'SELECT NOW()' },
  },
});
",
  "import { BaseEntity as MikroORM_BaseEntity, Config as MikroORM_Config, type DefineConfig as MikroORM_DefineConfig, EntitySchema as MikroORM_EntitySchema } from '@mikro-orm/core';

export abstract class CustomBase extends MikroORM_BaseEntity {
  [MikroORM_Config]?: MikroORM_DefineConfig<{ forceObject: true }>;
}

export const CustomBaseSchema = new MikroORM_EntitySchema({
  class: CustomBase,
  properties: {
  },
});
",
]
`;
